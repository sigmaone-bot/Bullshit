local ok, name, ver = pcall(identifyexecutor)
if ok and name then
    name = string.lower(name)
    if string.find(name, "ronix") then
        game:GetService("Players").LocalPlayer:Kick("Skid Executor ðŸ¥€")
    end
end
setclipboard("https://discord.gg/c8bg89UUEe")
getgenv().Players = game:GetService("Players")
getgenv().playerData = game:GetService("Players").LocalPlayer:WaitForChild("PlayerData")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().RunService = game:GetService("RunService")
getgenv().MarketplaceService = game:GetService("MarketplaceService")
getgenv().RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
getgenv().TweenService = game:GetService("TweenService")
getgenv().PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
local Humanoid, Animator
getgenv().player = Players.LocalPlayer
getgenv().purchasedEmotesFolder = playerData:WaitForChild("Purchased"):WaitForChild("Emotes")
getgenv().Remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local LocalPlayer = Players.LocalPlayer
local lp = Players.LocalPlayer
local player = Players.LocalPlayer
local function getPing()
    return LocalPlayer:GetNetworkPing()
end
local function pingBasedDelay(baseDelay)
    local ping = getPing()
    local adjustedDelay = baseDelay + ping
    task.wait(adjustedDelay)
end
local function delayKillerIntroUI()
    local ui
    repeat
        ui = player.PlayerGui:FindFirstChild("KillerIntroUI")
        task.wait(LocalPlayer:GetNetworkPing())
    until ui
    repeat
        task.wait(LocalPlayer:GetNetworkPing())
    until #ui:GetChildren() == 0
end
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "Nyansaken",
   Icon = 134395825211880,
   LoadingTitle = "Loading Nyansaken...",
   LoadingSubtitle = "by LQK And ImANyan",
   ShowText = "Nyansaken",
   Theme = "Default",
   ToggleUIKeybind = "K",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "nyansaken",
      FileName = "nyan-saken"
   },
   KeySystem = true,
   KeySettings = {
      Title = "Nyan-System",
      Subtitle = "Key System",
      Note = "(discord.gg/c8bg89UUEe) - Join our discord right now, and check your clipboard",
      FileName = "nyansakenkey",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"GHOSTINGCFRAME", "NYAN", "SIGMASAKEN", "GUESTIV", "FAKELAG", "TIMELESS", "NEWAUTOBLOCK"}
   }
})
local Combat = Window:CreateTab("Combat", "swords")
local Generators = Window:CreateTab("Generators", "package-2")
local ESP = Window:CreateTab("ESP", "scan-eye")
local StaminaSet = Window:CreateTab("Stamina Settings", "footprints")
local Aimbot = Window:CreateTab("Aimbot", "crosshair")
local Miscs = Window:CreateTab("Misc", "circle-ellipsis")
local AntiSlows = Window:CreateTab("Anti Slow", "accessibility")
local AchieveTab = Window:CreateTab("Achievements", "medal")
getgenv().AutoGenEnabled = false
getgenv().TimePerGenPhase = 1.25
getgenv().RunService = game:GetService("RunService")
getgenv().plr = game.Players.LocalPlayer
getgenv().Players = game:GetService("Players")
getgenv().UserInputService = game:GetService("UserInputService")
getgenv().TweenService = game:GetService("TweenService")
getgenv().player = Players.LocalPlayer
getgenv().playerGui = player:WaitForChild("PlayerGui")
getgenv().AddTextOutline = function(obj)
	if not (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) then return end
	local outlineFolder = Instance.new("Folder")
	outlineFolder.Name = "TextOutline"
	outlineFolder.Parent = obj
	local offsets = {
		Vector2.new(-1, 0), Vector2.new(1, 0),
		Vector2.new(0, -1), Vector2.new(0, 1),
		Vector2.new(-1, -1), Vector2.new(1, 1),
		Vector2.new(-1, 1), Vector2.new(1, -1)
	}
	for _, offset in ipairs(offsets) do
		local shadow = Instance.new("TextLabel")
		shadow.BackgroundTransparency = 1
		shadow.Size = obj.Size
		shadow.Position = UDim2.fromOffset(offset.X, offset.Y)
		shadow.AnchorPoint = obj.AnchorPoint
		shadow.ZIndex = obj.ZIndex - 1
		shadow.Text = obj.Text
		shadow.Font = obj.Font
		shadow.TextSize = obj.TextSize
		shadow.TextColor3 = Color3.fromRGB(0, 0, 0)
		shadow.TextXAlignment = obj.TextXAlignment
		shadow.TextYAlignment = obj.TextYAlignment
		shadow.Parent = outlineFolder
	end
	obj.TextColor3 = Color3.fromRGB(255, 255, 255)
	obj:GetPropertyChangedSignal("Text"):Connect(function()
		for _, shadow in ipairs(outlineFolder:GetChildren()) do
			shadow.Text = obj.Text
		end
	end)
end
getgenv().screenGui = Instance.new("ScreenGui")
screenGui.Name = "ManualUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 999999
screenGui.Parent = playerGui
screenGui.Enabled = false
getgenv().screenSize = screenGui.AbsoluteSize
getgenv().screenWidth = screenSize.X
getgenv().screenHeight = screenSize.Y
getgenv().frameWidth = screenWidth * 0.25
getgenv().frameHeight = screenHeight * 0.12
getgenv().frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.Size = UDim2.new(0, frameWidth, 0, frameHeight)
frame.Position = UDim2.new(0.5, -frameWidth / 2, 0.5, -frameHeight / 2)
frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
frame.BorderSizePixel = 0
frame.Active = true
frame.Parent = screenGui
getgenv().corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = frame
getgenv().stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(0, 0, 0)
stroke.Transparency = 0.3
stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
stroke.Parent = frame
getgenv().textBox = Instance.new("TextBox")
textBox.Name = "CDTextBox"
textBox.Size = UDim2.new(1, 0, 0.5, -2)
textBox.Position = UDim2.new(0, 0, 0, 0)
textBox.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
textBox.BorderSizePixel = 0
textBox.Text = "2.5"
textBox.TextSize = 15
textBox.Font = Enum.Font.GothamBold
textBox.TextXAlignment = Enum.TextXAlignment.Center
textBox.TextYAlignment = Enum.TextYAlignment.Center
textBox.ClearTextOnFocus = false
textBox.Parent = frame
Instance.new("UICorner", textBox).CornerRadius = UDim.new(0, 8)
Instance.new("UIStroke", textBox).Thickness = 1.5
textBox.UIStroke.Color = Color3.fromRGB(0, 0, 0)
textBox.UIStroke.Transparency = 0.3
AddTextOutline(textBox)
getgenv().button = Instance.new("TextButton")
button.Name = "ClickButton"
button.Size = UDim2.new(1, 0, 0.5, -2)
button.Position = UDim2.new(0, 0, 0.5, 2)
button.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
button.BorderSizePixel = 0
button.Text = "Cl1ck t0 d0 g3n3r4t0r5"
button.TextSize = 15
button.Font = Enum.Font.GothamBold
button.TextXAlignment = Enum.TextXAlignment.Center
button.TextYAlignment = Enum.TextYAlignment.Center
button.Parent = frame
Instance.new("UICorner", button).CornerRadius = UDim.new(0, 8)
Instance.new("UIStroke", button).Thickness = 1.5
button.UIStroke.Color = Color3.fromRGB(0, 0, 0)
button.UIStroke.Transparency = 0.3
AddTextOutline(button)
getgenv().defaultColor = Color3.fromRGB(0, 170, 0)
getgenv().hoverColor = Color3.fromRGB(0, 200, 0)
getgenv().cooldownColor = Color3.fromRGB(170, 0, 0)
getgenv().isCooldown = false
getgenv().currentCD = 2.5
button.MouseEnter:Connect(function()
	if not isCooldown then
		button.BackgroundColor3 = hoverColor
	end
end)
button.MouseLeave:Connect(function()
	if not isCooldown then
		button.BackgroundColor3 = defaultColor
	end
end)
getgenv().startCooldown = function()
	if isCooldown then return end
	task.spawn(function()
		local m = workspace:FindFirstChild("Map")
		if m and m:FindFirstChild("Ingame") and m.Ingame:FindFirstChild("Map") then
			for _, v in pairs(m.Ingame.Map:GetChildren()) do
				if v:IsA("Model") and v.Name == "Generator" then
					local r = v:FindFirstChild("Remotes") and v.Remotes:FindFirstChild("RE")
					if r then r:FireServer() end
				end
			end
		end
	end)
	local cdInput = tonumber(textBox.Text) or 2.5
	isCooldown = true
	currentCD = cdInput
	button.Active = false
	button.BackgroundColor3 = cooldownColor
	task.spawn(function()
		while currentCD > 0 do
			currentCD -= 0.1
			button.Text = string.format("%.1f", math.max(0, currentCD))
			task.wait(0.1)
		end
		isCooldown = false
		button.Text = "Cl1ck t0 d0 g3n3r4t0r5"
		button.BackgroundColor3 = defaultColor
		button.Active = true
	end)
end
getgenv().dragging = false
getgenv().dragInput = nil
getgenv().dragStart = nil
getgenv().startPos = nil
frame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

frame.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end
end)
Generators:CreateToggle({
	Name = "Auto Do Generator (Button)",
	CurrentValue = false,
	Flag = "AutoDoGeneratorButton",
	Callback = function(value)
		screenGui.Enabled = value
	end,
})
RunService.RenderStepped:Connect(function()
    if not getgenv().AutoGenEnabled then return end
    if not plr.PlayerGui:FindFirstChild("PuzzleUI") then return end
    local char = plr.Character or plr.CharacterAdded:Wait()
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local closest, dist = nil, math.huge
    local mapFolder = workspace:FindFirstChild("Map")
        and workspace.Map:FindFirstChild("Ingame")
        and workspace.Map.Ingame:FindFirstChild("Map")
    if mapFolder then
        for _, gen in ipairs(mapFolder:GetChildren()) do
            if gen:IsA("Model") and gen.Name == "Generator" and gen.PrimaryPart then
                local d = (root.Position - gen.PrimaryPart.Position).Magnitude
                if d < dist then
                    closest, dist = gen, d
                end
            end
        end
    end
    if closest and closest:FindFirstChild("Remotes") and closest.Remotes:FindFirstChild("RE") then
        if not getgenv()._lastFire or tick() - getgenv()._lastFire >= getgenv().TimePerGenPhase then
            getgenv()._lastFire = tick()
            pcall(function() closest.Remotes.RE:FireServer() end)
        end
    end
end)
if Generators then
    Generators:CreateToggle({
        Name = "Auto Do Generator",
        CurrentValue = getgenv().AutoGenEnabled,
        Flag = "AutoGenToggle",
        Callback = function(value)
            getgenv().AutoGenEnabled = value
        end,
    })
    Generators:CreateSlider({
        Name = "Do Generator Interval (Seconds)",
		Range = {1, 15},
		Increment = 0.25,
        Suffix = "s",
        CurrentValue = getgenv().TimePerGenPhase,
        Flag = "TimePerGenPhase",
        Callback = function(value)
            getgenv().TimePerGenPhase = value
        end,
    })
end
local genEnabled = false
local genInterval = 1.25
local generatorsDid = {}
local activelyAutoing = false
local autoGenToggle = Generators:CreateToggle({
	Name = "Auto Do Generator (No Puzzle UI)",
	CurrentValue = genEnabled,
	Flag = "AutoGenToggle",
	Callback = function(Value)
		_G.instantGenerator = Value
		task.spawn(function()
			while task.wait() do
				if not _G.instantGenerator then break end
				local gameMap = workspace:FindFirstChild("Map")
				if gameMap and gameMap:FindFirstChild("Ingame") and gameMap.Ingame:FindFirstChild("Map") then
					for _, v in pairs(gameMap.Ingame.Map:GetChildren()) do
						if not generatorsDid[v]
							and v.Name == "Generator"
							and v:FindFirstChild("Scripts")
							and v.Scripts:FindFirstChild("Client") then
							local env = getsenv(v.Scripts.Client)
							if env and env.toggleGeneratorState and not generatorsDid[v] then
								generatorsDid[v] = true
								local old
								old = hookfunction(env.toggleGeneratorState, newcclosure(function(a)
									if checkcaller() then
										return old(a)
									end
									if not _G.instantGenerator then
										return old(a)
									end
									if a ~= "enter" then
										activelyAutoing = false
										return old(a)
									end
									local result = v.Remotes.RF:InvokeServer("enter")
									if result ~= "fixing" then
										return
									end
									activelyAutoing = true
									for i = 1, 4 do
										if v.Progress.Value >= 100 then break end
										if not _G.instantGenerator or not activelyAutoing then break end
										task.wait(genInterval)
										v.Remotes.RE:FireServer()
									end
									activelyAutoing = false
									return ""
								end))
							end
						end
					end
				end
			end
		end)
	end,
})
local genIntervalSlider = Generators:CreateSlider({
	Name = "Do Generator Interval (Seconds) [No Puzzle UI]",
	Range = {1, 15},
	Increment = 0.25,
	Suffix = "s",
	CurrentValue = genInterval,
	Flag = "GenIntervalSlider",
	Callback = function(Value)
		genInterval = Value
	end,
})
getgenv().KillersESPEnabled = false
getgenv().SurvivorsESPEnabled = false
getgenv().KillersESPOutline = false
getgenv().SurvivorsESPOutline = false
getgenv().KillersESPColor = Color3.fromRGB(255, 0, 0)
getgenv().SurvivorsESPColor = Color3.fromRGB(255, 255, 0)
getgenv().KillersNametagEnabled = false
getgenv().SurvivorsNametagEnabled = false
ESP:CreateSection("Killers ESP")
ESP:CreateToggle({
    Name = "Killers ESP",
    CurrentValue = getgenv().KillersESPEnabled,
    Flag = "KillersESP",
    Callback = function(val) getgenv().KillersESPEnabled = val end
})
ESP:CreateToggle({
    Name = "Killers Outline",
    CurrentValue = getgenv().KillersESPOutline,
    Flag = "KillersESPOutline",
    Callback = function(val) getgenv().KillersESPOutline = val end
})
ESP:CreateToggle({
    Name = "Killers Nametags",
    CurrentValue = getgenv().KillersNametagEnabled,
    Flag = "KillersNametags",
    Callback = function(val) getgenv().KillersNametagEnabled = val end
})
ESP:CreateColorPicker({
    Name = "Killers Color",
    Color = getgenv().KillersESPColor,
    Flag = "KillersESPColor",
    Callback = function(color) getgenv().KillersESPColor = color end
})
ESP:CreateSection("Survivors ESP")
ESP:CreateToggle({
    Name = "Survivors ESP",
    CurrentValue = getgenv().SurvivorsESPEnabled,
    Flag = "SurvivorsESP",
    Callback = function(val) getgenv().SurvivorsESPEnabled = val end
})
ESP:CreateToggle({
    Name = "Survivors Outline",
    CurrentValue = getgenv().SurvivorsESPOutline,
    Flag = "SurvivorsESPOutline",
    Callback = function(val) getgenv().SurvivorsESPOutline = val end
})
ESP:CreateToggle({
    Name = "Survivors Nametags",
    CurrentValue = getgenv().SurvivorsNametagEnabled,
    Flag = "SurvivorsNametags",
    Callback = function(val) getgenv().SurvivorsNametagEnabled = val end
})
ESP:CreateColorPicker({
    Name = "Survivors Color",
    Color = getgenv().SurvivorsESPColor,
    Flag = "SurvivorsESPColor",
    Callback = function(color) getgenv().SurvivorsESPColor = color end
})
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
local function attachBillboard(model, color)
	if model:FindFirstChild("ESP_NameBillboard") then return end
	local head = model:FindFirstChild("Head") or model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
	if not head then return end
	local humanoid = model:FindFirstChildOfClass("Humanoid")
	local offsetY = 3
	if humanoid then
		offsetY = humanoid.HipHeight + 2
	end
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ESP_NameBillboard"
	billboard.Adornee = head
	billboard.StudsOffset = Vector3.new(0, offsetY, 0)
	billboard.AlwaysOnTop = true
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.Parent = model
	local label = Instance.new("TextLabel")
	label.Name = "NameLabel"
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.TextColor3 = color
	label.TextStrokeTransparency = 0
	label.TextStrokeColor3 = Color3.new(0, 0, 0)
	label.TextScaled = true
	label.TextWrapped = false
	label.TextTruncate = Enum.TextTruncate.None
	label.TextXAlignment = Enum.TextXAlignment.Center
	label.TextYAlignment = Enum.TextYAlignment.Center
	label.Font = Enum.Font.GothamBold
	label.Text = "Loading..."
	label.Parent = billboard
end
local function setupHighlight(model, color, outline)
	local highlight = model:FindFirstChild("ESP_Highlight")
	if not highlight then
		highlight = Instance.new("Highlight")
		highlight.Name = "ESP_Highlight"
		highlight.FillTransparency = 1
		highlight.Adornee = model
		highlight.Parent = model
	end
	highlight.OutlineTransparency = outline and 0 or 1
	highlight.OutlineColor = color
end
local function updateBillboardText(model)
	local billboard = model:FindFirstChild("ESP_NameBillboard")
	if not billboard then return end
	local label = billboard:FindFirstChild("NameLabel")
	if not label then return end
	local actorText = model:GetAttribute("ActorDisplayName") or "???"
	local skinText = model:GetAttribute("SkinNameDisplay")
	local username = model:GetAttribute("Username") or "Unknown"
	if actorText == "Noli" and model:GetAttribute("IsFakeNoli") == true then
		actorText = actorText .. " (Fake)"
	end
	local displayText = actorText
	if skinText and tostring(skinText) ~= "" then
		displayText = displayText .. " | " .. skinText
	end
	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if humanoid then
		local hp = math.floor(humanoid.Health)
		local maxhp = math.floor(humanoid.MaxHealth)
		displayText = string.format("%s (HP: %d/%d)", displayText, hp, maxhp)
	end
	label.Text = displayText
end
local noliByUsername = {}
local function clearFakeTags()
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:GetAttribute("ActorDisplayName") == "Noli" then
            killer:SetAttribute("IsFakeNoli", false)
        end
    end
end
local function scanNolis()
    noliByUsername = {}
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:GetAttribute("ActorDisplayName") == "Noli" then
            local username = killer:GetAttribute("Username")
            if username then
                if not noliByUsername[username] then
                    noliByUsername[username] = {}
                end
                table.insert(noliByUsername[username], killer)
            end
        end
    end
    for username, models in pairs(noliByUsername) do
        if #models > 1 then
            for i = 2, #models do
                models[i]:SetAttribute("IsFakeNoli", true)
            end
            models[1]:SetAttribute("IsFakeNoli", false)
        else
            models[1]:SetAttribute("IsFakeNoli", false)
        end
    end
end
local function updateFakeNolis()
    clearFakeTags()
    scanNolis()
end
local function setupModel(model, isKiller)
	if not model:IsA("Model") or model:GetAttribute("ESP_Initialized") then return end
	if not model:FindFirstChildOfClass("Humanoid") then return end
	local color = isKiller and getgenv().KillersESPColor or getgenv().SurvivorsESPColor
	local outline = isKiller and getgenv().KillersESPOutline or getgenv().SurvivorsESPOutline
	local showNametag = isKiller and getgenv().KillersNametagEnabled or getgenv().SurvivorsNametagEnabled
	setupHighlight(model, color, outline)
	if showNametag then
		attachBillboard(model, color)
		updateBillboardText(model)
	end
	model:GetAttributeChangedSignal("ActorDisplayName"):Connect(function() updateBillboardText(model) end)
	model:GetAttributeChangedSignal("SkinNameDisplay"):Connect(function() updateBillboardText(model) end)
	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid:GetPropertyChangedSignal("Health"):Connect(function() updateBillboardText(model) end)
		humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function() updateBillboardText(model) end)
	end
	model.AncestryChanged:Connect(function(_, parent)
		if not parent then
			local bb = model:FindFirstChild("ESP_NameBillboard")
			if bb then bb:Destroy() end
			local hl = model:FindFirstChild("ESP_Highlight")
			if hl then hl:Destroy() end
		end
	end)
	model:SetAttribute("ESP_Initialized", true)
end
local function scanFolder(folder, isKiller)
	for _, model in ipairs(folder:GetChildren()) do
		setupModel(model, isKiller)
	end
end
local function handleChildAdded(folder, isKiller)
	folder.ChildAdded:Connect(function(child)
		task.spawn(function()
			repeat task.wait() until child:IsDescendantOf(folder)
			local timeout = 3
			local timer = 0
			while (not child:FindFirstChild("Head") and not child:FindFirstChildWhichIsA("BasePart")) or not child:FindFirstChildOfClass("Humanoid") do
				task.wait(0.1)
				timer = timer + 0.1
				if timer > timeout then return end
			end
			task.wait(0.2)
			setupModel(child, isKiller)
		end)
	end)
end
task.spawn(function()
	while true do
		scanFolder(killersFolder, true)
		scanFolder(survivorsFolder, false)
		task.wait(5)
	end
end)
handleChildAdded(killersFolder, true)
handleChildAdded(survivorsFolder, false)
updateFakeNolis()
killersFolder.ChildRemoved:Connect(function(removed)
    if removed:GetAttribute("ActorDisplayName") == "Noli" then
        updateFakeNolis()
    end
end)
killersFolder.ChildAdded:Connect(function(added)
    if added:GetAttribute("ActorDisplayName") == "Noli" then
        task.defer(function()
            task.wait(0.2)
            updateFakeNolis()
        end)
    end
end)
task.spawn(function()
    while true do
        task.wait(10)
        updateFakeNolis()
    end
end)
RunService.RenderStepped:Connect(function()
	for _, data in pairs({
		{folder = killersFolder, toggle = getgenv().KillersESPEnabled, color = getgenv().KillersESPColor, outline = getgenv().KillersESPOutline, nametag = getgenv().KillersNametagEnabled},
		{folder = survivorsFolder, toggle = getgenv().SurvivorsESPEnabled, color = getgenv().SurvivorsESPColor, outline = getgenv().SurvivorsESPOutline, nametag = getgenv().SurvivorsNametagEnabled}
	}) do
		for _, model in ipairs(data.folder:GetChildren()) do
			if not model:IsA("Model") then
			else
				local bb = model:FindFirstChild("ESP_NameBillboard")
				local hl = model:FindFirstChild("ESP_Highlight")
				if hl then
					hl.Enabled = data.toggle
					hl.OutlineTransparency = data.outline and 0 or 1
					hl.OutlineColor = data.color
				else
					if data.toggle then
						setupHighlight(model, data.color, data.outline)
					end
				end
				if data.toggle and data.nametag then
					if not bb then
						attachBillboard(model, data.color)
						bb = model:FindFirstChild("ESP_NameBillboard")
					end
					if bb and bb.Adornee then
						bb.Enabled = true
						updateBillboardText(model)
						local success, pos = pcall(function() return bb.Adornee.Position end)
						if success and bb.Adornee then
							local dist = (camera.CFrame.Position - bb.Adornee.Position).Magnitude
							local scale = math.clamp(1 / (dist / 20), 0.5, 2)
							local label = bb:FindFirstChild("NameLabel")
							if label then
								label.TextColor3 = data.color
								label.TextSize = math.clamp(10 * scale, 12, 20)
								local width = 200
								if label.TextBounds and label.TextBounds.X and label.TextBounds.X > 0 then
									width = math.max(200, label.TextBounds.X + 20)
								end
								bb.Size = UDim2.new(0, width, 0, 50 * scale)
							end
						end
					end
				else
					if bb then
						bb.Enabled = false
					end
				end
			end
		end
	end
end)
local espParts = {}
local partEspTrigger = nil
local defaultColors = {
	BloxyCola = Color3.fromRGB(255, 165, 0),
	Medkit = Color3.fromRGB(255, 182, 255),
	AssaultRifle = Color3.fromRGB(144, 238, 144),
	Broadsword = Color3.fromRGB(255, 255, 255),
	Epicsauce = Color3.fromRGB(255, 182, 193),
	FakeBloxyCola = Color3.fromRGB(255, 200, 150),
	FakeMedkit = Color3.fromRGB(255, 182, 255),
	Flashlight = Color3.fromRGB(245, 245, 245),
	Glock = Color3.fromRGB(0, 0, 139),
	GravityGun = Color3.fromRGB(255, 255, 0),
}
getgenv().ItemESP_Enabled = false
getgenv().ItemESP_Fill = false
getgenv().ItemESP_Nametag = false
getgenv().ItemESP_Color = false
getgenv().ItemESP_CustomColors = {}
for name, color in pairs(defaultColors) do
	getgenv().ItemESP_CustomColors[name] = color
end
local function updateNameTag(part, tagName, color)
	if not getgenv().ItemESP_Nametag then
		if part:FindFirstChild("ESP_Billboard") then
			part.ESP_Billboard:Destroy()
		end
		return
	end
	local billboard = part:FindFirstChild("ESP_Billboard")
	if not billboard then
		billboard = Instance.new("BillboardGui")
		billboard.Name = "ESP_Billboard"
		billboard.Size = UDim2.new(0, 100, 0, 30)
		billboard.Adornee = part
		billboard.AlwaysOnTop = true
		billboard.StudsOffset = Vector3.new(0, 2.5, 0)
		billboard.Parent = part
		local textLabel = Instance.new("TextLabel")
		textLabel.Name = "TextLabel"
		textLabel.Size = UDim2.new(1, 0, 1, 0)
		textLabel.BackgroundTransparency = 1
		textLabel.Font = Enum.Font.SourceSansBold
		textLabel.TextScaled = false
		textLabel.TextSize = 13
		textLabel.Parent = billboard
	end
	billboard.TextLabel.Text = tagName
	billboard.TextLabel.TextColor3 = color
end
local function updateBox(part, tagName, color)
	local box = part:FindFirstChild(tagName.."_PESP")
	if getgenv().ItemESP_Fill then
		if not box then
			box = Instance.new("BoxHandleAdornment")
			box.Name = tagName.."_PESP"
			box.Adornee = part
			box.Size = part.Size
			box.Transparency = 0.5
			box.ZIndex = 0
			box.AlwaysOnTop = true
			box.Parent = part
		end
		box.Color3 = color
	else
		if box then
			box:Destroy()
		end
	end
end
local function updateESP(part)
	if not getgenv().ItemESP_Enabled then return end
	if not part or not part:IsA("BasePart") then return end
	if part.Name ~= "ItemRoot" or not part.Parent then return end
	local tagName = part.Parent.Name
	local color = getgenv().ItemESP_Color and (getgenv().ItemESP_CustomColors[tagName] or Color3.fromRGB(255,255,255)) or Color3.fromRGB(255,255,255)
	updateBox(part, tagName, color)
	updateNameTag(part, tagName, color)
end
local function enableItemESP()
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Name == "ItemRoot" then
			updateESP(v)
		end
	end
	if not partEspTrigger then
		partEspTrigger = workspace.DescendantAdded:Connect(function(part)
			if part:IsA("BasePart") and part.Name == "ItemRoot" then
				updateESP(part)
			end
		end)
	end
end
local function disableItemESP()
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Name == "ItemRoot" then
			if v:FindFirstChild("ESP_Billboard") then v.ESP_Billboard:Destroy() end
			local tagName = v.Parent and v.Parent.Name
			if tagName and v:FindFirstChild(tagName.."_PESP") then
				v[tagName.."_PESP"]:Destroy()
			end
		end
	end
	if partEspTrigger then
		partEspTrigger:Disconnect()
		partEspTrigger = nil
	end
end
ESP:CreateSection("Items ESP")
ESP:CreateToggle({
	Name = "Items ESP",
	CurrentValue = false,
	Flag = "ItemESP_Main",
	Callback = function(Value)
		getgenv().ItemESP_Enabled = Value
		if Value then enableItemESP() else disableItemESP() end
	end,
})
ESP:CreateToggle({
	Name = "Item ESP Fill",
	CurrentValue = false,
	Flag = "ItemESP_Fill",
	Callback = function(Value)
		getgenv().ItemESP_Fill = Value
		for _, v in pairs(workspace:GetDescendants()) do
			if v:IsA("BasePart") and v.Name == "ItemRoot" then updateESP(v) end
		end
	end,
})
ESP:CreateToggle({
	Name = "Item ESP Nametag",
	CurrentValue = false,
	Flag = "ItemESP_Nametag",
	Callback = function(Value)
		getgenv().ItemESP_Nametag = Value
		for _, v in pairs(workspace:GetDescendants()) do
			if v:IsA("BasePart") and v.Name == "ItemRoot" then updateESP(v) end
		end
	end,
})
ESP:CreateToggle({
	Name = "Item ESP Color",
	CurrentValue = false,
	Flag = "ItemESP_Color",
	Callback = function(Value)
		getgenv().ItemESP_Color = Value
		for _, v in pairs(workspace:GetDescendants()) do
			if v:IsA("BasePart") and v.Name == "ItemRoot" then updateESP(v) end
		end
	end,
})
for itemName, color in pairs(getgenv().ItemESP_CustomColors) do
	ESP:CreateColorPicker({
		Name = itemName .. " Color",
		Flag = "ItemESP_Color_"..itemName,
		Color = color,
		Callback = function(c)
			getgenv().ItemESP_CustomColors[itemName] = c
			for _, v in pairs(workspace:GetDescendants()) do
				if v:IsA("BasePart") and v.Name == "ItemRoot" and v.Parent.Name == itemName then
					updateESP(v)
				end
			end
		end
	})
end
getgenv().GeneratorsESPEnabled = false
getgenv().GeneratorESPFill = false
getgenv().GeneratorESPOutline = false
getgenv().GeneratorsESPGreen = false
getgenv().GeneratorsNametagsEnabled = false
getgenv().GeneratorsESPColor = Color3.fromRGB(255, 255, 255)
ESP:CreateSection("Generators ESP")
ESP:CreateToggle({
    Name = "Generators ESP",
    CurrentValue = getgenv().GeneratorsESPEnabled,
    Flag = "GeneratorsESP",
    Callback = function(value)
        getgenv().GeneratorsESPEnabled = value
        if not value then
            pcall(function()
                if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") then
                    for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                        if gen.Name == "Generator" then
                            if gen:FindFirstChild("iskiddedfromneptz") then
                                gen.iskiddedfromneptz:Destroy()
                            end
                            if gen:FindFirstChild("nametag") then
                                gen.nametag:Destroy()
                            end
                        end
                    end
                end
            end)
        end
    end
})
ESP:CreateToggle({
    Name = "Generators Show Fill",
    CurrentValue = getgenv().GeneratorESPFill,
    Flag = "GeneratorESPFill",
    Callback = function(value)
        getgenv().GeneratorESPFill = value
    end
})
ESP:CreateToggle({
    Name = "Generators Show Outline",
    CurrentValue = getgenv().GeneratorESPOutline,
    Flag = "GeneratorESPOutline",
    Callback = function(value)
        getgenv().GeneratorESPOutline = value
    end
})
ESP:CreateToggle({
    Name = "Generators Show Green When Done",
    CurrentValue = getgenv().GeneratorsESPGreen,
    Flag = "GeneratorsESPGreen",
    Callback = function(value)
        getgenv().GeneratorsESPGreen = value
    end
})
ESP:CreateToggle({
    Name = "Generators Nametags",
    CurrentValue = getgenv().GeneratorsNametagsEnabled,
    Flag = "GeneratorsNametags",
    Callback = function(value)
        getgenv().GeneratorsNametagsEnabled = value
    end
})
ESP:CreateColorPicker({
    Name = "Generators Color",
    Color = getgenv().GeneratorsESPColor,
    Flag = "GeneratorsESPColor",
    Callback = function(color)
        getgenv().GeneratorsESPColor = color
    end
})
local function ensureHighlight(gen)
    local hl = gen:FindFirstChild("iskiddedfromneptz")
    if not hl then
        hl = Instance.new("Highlight")
        hl.Name = "iskiddedfromneptz"
        hl.Parent = gen
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
    return hl
end
local function updateHighlight(gen)
    local hl = gen:FindFirstChild("iskiddedfromneptz")
    if not hl then return end
    local color = nil
    if getgenv().GeneratorESPFill then
        color = getgenv().GeneratorsESPColor
    end
    if getgenv().GeneratorsESPGreen and gen:FindFirstChild("Progress") and gen.Progress.Value >= 100 then
        color = Color3.fromRGB(0,255,0)
    end
    if color then
        if hl.FillColor ~= color then
            hl.FillColor = color
        end
        hl.Enabled = true
    else
        hl.Enabled = false
    end
    hl.OutlineTransparency = getgenv().GeneratorESPOutline and 0 or 1
end
local function MapProgress(val)
    if val == 0 then return 0
    elseif val == 26 then return 25
    elseif val == 52 then return 50
    elseif val == 78 then return 75
    elseif val == 100 then return 100
    else return val
    end
end
local function updateNametag(gen)
    if not getgenv().GeneratorsNametagsEnabled then
        if gen:FindFirstChild("nametag") then
            gen.nametag:Destroy()
        end
        return
    end
    local progress = gen:FindFirstChild("Progress") and gen.Progress.Value or 0
    local displayValue = MapProgress(progress)
    local bb = gen:FindFirstChild("nametag")
    if not bb then
        bb = Instance.new("BillboardGui")
        bb.Name = "nametag"
        bb.Adornee = gen
        bb.Parent = gen
        bb.Size = UDim2.new(0, 200, 0, 50)
        bb.StudsOffset = Vector3.new(0, 3, 0)
        bb.AlwaysOnTop = true
        local text = Instance.new("TextLabel")
        text.Name = "TextLabel"
        text.Parent = bb
        text.Size = UDim2.fromScale(1,1)
        text.BackgroundTransparency = 1
        text.TextColor3 = getgenv().GeneratorsESPColor
        text.TextStrokeTransparency = 0
        text.TextSize = 13
        text.Font = Enum.Font.GothamBold
        text.Text = "Generator ("..displayValue.."%)"
    else
        bb.TextLabel.Text = "Generator ("..displayValue.."%)"
        bb.TextLabel.TextColor3 = getgenv().GeneratorsESPColor
    end
end
local RunService = game:GetService("RunService")
RunService.Heartbeat:Connect(function()
    if not getgenv().GeneratorsESPEnabled then return end
    if not workspace:FindFirstChild("Map") or not workspace.Map:FindFirstChild("Ingame") then return end
    local mapFolder = workspace.Map.Ingame:FindFirstChild("Map")
    if not mapFolder then return end
    for _, gen in pairs(mapFolder:GetChildren()) do
        if gen.Name == "Generator" then
            if getgenv().GeneratorESPFill or getgenv().GeneratorESPOutline or getgenv().GeneratorsESPGreen then
                ensureHighlight(gen)
                updateHighlight(gen)
            else
                if gen:FindFirstChild("iskiddedfromneptz") then
                    gen.iskiddedfromneptz:Destroy()
                end
            end
            updateNametag(gen)
        end
    end
end)
getgenv().FakeGeneratorsESPEnabled = false
getgenv().FakeGeneratorESPFill = false
getgenv().FakeGeneratorESPOutline = false
getgenv().FakeGeneratorsESPColor = Color3.fromRGB(255, 150, 150)
getgenv().FakeGeneratorsNametagsEnabled = false
ESP:CreateSection("Fake Generators ESP")
ESP:CreateToggle({
    Name = "Fake Generators ESP",
    CurrentValue = getgenv().FakeGeneratorsESPEnabled,
    Flag = "FakeGeneratorsESP",
    Callback = function(value)
        getgenv().FakeGeneratorsESPEnabled = value
        if not value then
            pcall(function()
                if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") then
                    for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                        if gen.Name == "FakeGenerator" then
                            if gen:FindFirstChild("iskiddedfromneptz") then gen.iskiddedfromneptz:Destroy() end
                            if gen:FindFirstChild("nametag") then gen.nametag:Destroy() end
                        end
                    end
                end
            end)
        end
    end
})
ESP:CreateToggle({
    Name = "Fake Generators Show Fill",
    CurrentValue = getgenv().FakeGeneratorESPFill,
    Flag = "FakeGeneratorESPFill",
    Callback = function(value)
        task.spawn(function()
            getgenv().FakeGeneratorESPFill = value
            while task.wait(0.1) do
                if not getgenv().FakeGeneratorESPFill then
                    pcall(function()
                        if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") then
                            for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                                if gen.Name == "FakeGenerator" and gen:FindFirstChild("iskiddedfromneptz") then
                                    gen.iskiddedfromneptz:Destroy()
                                end
                            end
                        end
                    end)
                    break
                end
                pcall(function()
                    if getgenv().FakeGeneratorsESPEnabled and getgenv().FakeGeneratorESPFill then
                        for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                            if gen.Name == "FakeGenerator" then
                                if not gen:FindFirstChild("iskiddedfromneptz") then
                                    local hl = Instance.new("Highlight")
                                    hl.Name = "iskiddedfromneptz"
                                    hl.Parent = gen
                                    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                                end
                                if gen:FindFirstChild("iskiddedfromneptz") then
                                    gen.iskiddedfromneptz.OutlineTransparency = getgenv().FakeGeneratorESPOutline and 0 or 1
                                    gen.iskiddedfromneptz.FillColor = getgenv().FakeGeneratorsESPColor
                                end
                            end
                        end
                    end
                end)
            end
        end)
    end
})
ESP:CreateToggle({
    Name = "Fake Generators Show Outline",
    CurrentValue = getgenv().FakeGeneratorESPOutline,
    Flag = "FakeGeneratorESPOutline",
    Callback = function(value)
        getgenv().FakeGeneratorESPOutline = value
        if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") then
            for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                if gen.Name == "FakeGenerator" and gen:FindFirstChild("iskiddedfromneptz") then
                    gen.iskiddedfromneptz.OutlineTransparency = value and 0 or 1
                end
            end
        end
    end
})
ESP:CreateToggle({
    Name = "Fake Generators Nametags",
    CurrentValue = getgenv().FakeGeneratorsNametagsEnabled,
    Flag = "FakeGeneratorsNametags",
    Callback = function(value)
        getgenv().FakeGeneratorsNametagsEnabled = value
        task.spawn(function()
            while task.wait(0.1) do
                if not getgenv().FakeGeneratorsNametagsEnabled then
                    pcall(function()
                        if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") then
                            for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                                if gen.Name == "FakeGenerator" and gen:FindFirstChild("nametag") then
                                    gen.nametag:Destroy()
                                end
                            end
                        end
                    end)
                    break
                end
                pcall(function()
                    if getgenv().FakeGeneratorsESPEnabled and getgenv().FakeGeneratorsNametagsEnabled then
                        for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                            if gen.Name == "FakeGenerator" then
                                if not gen:FindFirstChild("nametag") then
                                    local bb = Instance.new("BillboardGui")
                                    bb.Name = "nametag"
                                    bb.Adornee = gen
                                    bb.Parent = gen
                                    bb.Size = UDim2.new(0, 200, 0, 50)
                                    bb.StudsOffset = Vector3.new(0, 3, 0)
                                    bb.AlwaysOnTop = true
                                    local text = Instance.new("TextLabel")
                                    text.Name = "TextLabel"
                                    text.Parent = bb
                                    text.Size = UDim2.fromScale(1, 1)
                                    text.BackgroundTransparency = 1
                                    text.TextColor3 = getgenv().FakeGeneratorsESPColor
                                    text.TextStrokeTransparency = 0
                                    text.TextSize = 13
                                    text.TextScaled = false
                                    text.Font = Enum.Font.GothamBold
                                    text.Text = "Fake Generator"
                                else
                                    gen.nametag.TextLabel.Text = "Fake Generator"
                                    gen.nametag.TextLabel.TextColor3 = getgenv().FakeGeneratorsESPColor
                                end
                            end
                        end
                    end
                end)
            end
        end)
    end
})
ESP:CreateColorPicker({
    Name = "Fake Generators Color",
    Flag = "FakeGeneratorsColor",
    Color = getgenv().FakeGeneratorsESPColor,
    Callback = function(color)
        getgenv().FakeGeneratorsESPColor = color
        if workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") then
            for _, gen in pairs(workspace.Map.Ingame.Map:GetChildren()) do
                if gen.Name == "FakeGenerator" then
                    if gen:FindFirstChild("iskiddedfromneptz") then
                        gen.iskiddedfromneptz.FillColor = color
                    end
                    if gen:FindFirstChild("nametag") then
                        gen.nametag.TextLabel.TextColor3 = color
                    end
                end
            end
        end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
getgenv().AimbotConfig = getgenv().AimbotConfig or {}
getgenv().AimbotConfig.Slash = getgenv().AimbotConfig.Slash or { Enabled = false, Smoothness = 1, Prediction = 0.25, Duration = 2 }
getgenv().AimbotConfig.Charge = getgenv().AimbotConfig.Charge or { Enabled = false, Smoothness = 1, Prediction = 0.25, Duration = 1.5 }
getgenv().AimbotConfig.Punch = getgenv().AimbotConfig.Punch or { Enabled = false, Smoothness = 1, Prediction = 0.25, Duration = 1.5 }
getgenv().AimbotConfig.ThrowPizza = getgenv().AimbotConfig.ThrowPizza or { Enabled = false, Smoothness = 1, Prediction = 0.25, Duration = 1.5 }
getgenv().AimbotConfig.Killers = getgenv().AimbotConfig.Killers or { Enabled = false, Duration = 3 }
getgenv().AimbotConfig.SelectedSkills = getgenv().AimbotConfig.SelectedSkills or {
    "Slash", "Punch", "Stab", "Nova", "VoidRush",
    "WalkspeedOverride", "Behead", "GashingWound",
    "CorruptNature", "CorruptEnergy", "MassInfection", "Entanglement"}
getgenv().AimbotConfig.Mode = getgenv().AimbotConfig.Mode or "Aimbot"
local function getNearestTargetByDistance()
    local nearest
    local shortestDistance = math.huge
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = myChar.HumanoidRootPart.Position
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoid and root and humanoid.MaxHealth <= 300 then
                local dist = (root.Position - myPos).Magnitude
                if dist < shortestDistance then
                    shortestDistance = dist
                    nearest = player
                end
            end
        end
    end
    return nearest
end
local function getNearestTargetByMaxHP(minHP)
    local closestPlayer
    local closestDistance = math.huge
    local myCharacter = LocalPlayer.Character
    if not myCharacter or not myCharacter:FindFirstChild("HumanoidRootPart") then return nil end
    local myPosition = myCharacter.HumanoidRootPart.Position
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= LocalPlayer and otherPlayer.Character then
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHumanoid and otherRoot and otherHumanoid.Health > 0 and otherHumanoid.MaxHealth >= minHP then
                local distance = (otherRoot.Position - myPosition).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = otherPlayer
                end
            end
        end
    end
    return closestPlayer
end
local function aimrootpart(target, duration, prediction, smoothness)
    if not target or not target.Character then return end
    local myChar = LocalPlayer.Character
    if not myChar then return end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    local startTime = tick()
    local conn
    conn = RunService.RenderStepped:Connect(function()
        if tick() - startTime > duration or not targetRoot.Parent or not myRoot.Parent then
            conn:Disconnect()
            return
        end
        local predictedPos = targetRoot.Position + targetRoot.Velocity * prediction
        local desiredCFrame = CFrame.lookAt(myRoot.Position, predictedPos)
        myRoot.CFrame = myRoot.CFrame:Lerp(desiredCFrame, math.clamp(smoothness, 0, 1))
    end)
end
local function aimlock(target, duration, prediction, smoothness)
    if not target or not target.Character then return end
    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    local startTime = tick()
    local conn
    conn = RunService.RenderStepped:Connect(function()
        if tick() - startTime > duration or not targetRoot.Parent then
            conn:Disconnect()
            return
        end
        local predictedPos = targetRoot.Position + targetRoot.Velocity * prediction
        local desiredCFrame = CFrame.new(Camera.CFrame.Position, predictedPos)
        Camera.CFrame = Camera.CFrame:Lerp(desiredCFrame, math.clamp(smoothness, 0, 1))
    end)
end
local function aimTarget(target, duration, prediction, smoothness)
    if not target then return end
    if getgenv().AimbotConfig.Mode == "Aimbot" then
        aimlock(target, duration, prediction, smoothness)
    elseif getgenv().AimbotConfig.Mode == "RootPart" then
        aimrootpart(target, duration, prediction, smoothness)
    end
end
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
RemoteEvent.OnClientEvent:Connect(function(...)
    local args = {...}
    if args[1] ~= "UseActorAbility" then return end
    local skillTable = args[2]
    if not skillTable or #skillTable == 0 then return end
	local skillName = buffer.tostring(skillTable[1])
	skillName = skillName:gsub('^"', ''):gsub('"$', '')
    if skillName == "Slash" and getgenv().AimbotConfig.Slash.Enabled and character.Name == "Shedletsky" then
        local target = getNearestTargetByMaxHP(300)
        if target then
            aimTarget(target, getgenv().AimbotConfig.Slash.Duration, getgenv().AimbotConfig.Slash.Prediction, getgenv().AimbotConfig.Slash.Smoothness)
        end
    end
    if skillName == "Punch" and getgenv().AimbotConfig.Punch.Enabled then
        local target = getNearestTargetByMaxHP(300)
        if target then
            aimTarget(target, getgenv().AimbotConfig.Punch.Duration, getgenv().AimbotConfig.Punch.Prediction, getgenv().AimbotConfig.Punch.Smoothness)
        end
    end
    if skillName == "Charge" and getgenv().AimbotConfig.Charge.Enabled then
        local target = getNearestTargetByMaxHP(300)
        if target then
            aimTarget(target, getgenv().AimbotConfig.Charge.Duration, getgenv().AimbotConfig.Charge.Prediction, getgenv().AimbotConfig.Charge.Smoothness)
        end
    end
    if skillName == "ThrowPizza" and getgenv().AimbotConfig.ThrowPizza.Enabled then
        local target = getNearestTargetByDistance()
        if target then
            aimTarget(target, getgenv().AimbotConfig.ThrowPizza.Duration, getgenv().AimbotConfig.ThrowPizza.Prediction, getgenv().AimbotConfig.ThrowPizza.Smoothness)
        end
    end
local LocalPlayer = game.Players.LocalPlayer
if getgenv().AimbotConfig.Killers.Enabled then
    local found = false
    for _, v in ipairs(getgenv().AimbotConfig.SelectedSkills) do
        if skillName == v then
            found = true
            break
        end
    end
    local char = LocalPlayer.Character
    if found and char and char.Parent and char.Parent.Name == "Killers" then
        local target = getNearestTargetByDistance()
        if target then
            aimTarget(target, getgenv().AimbotConfig.Killers.Duration, 0, 1)
        end
    end
end
end)
Aimbot:CreateSection("Shedletsky")
Aimbot:CreateToggle({
    Name = "Aimbot Slash",
    CurrentValue = getgenv().AimbotConfig.Slash.Enabled,
    Flag = "AutoAimSlash",
    Callback = function(Value)
        getgenv().AimbotConfig.Slash.Enabled = Value
    end,
})
Aimbot:CreateSlider({
    Name = "Smoothness Slash",
    Range = {0, 101},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = getgenv().AimbotConfig.Slash.Smoothness * 100,
    Flag = "SmoothnessSlash",
    Callback = function(Value)
        getgenv().AimbotConfig.Slash.Smoothness = Value / 100
    end,
})
Aimbot:CreateSlider({
    Name = "Prediction Slash",
    Range = {0, 2},
    Increment = 0.05,
    Suffix = "s",
    CurrentValue = getgenv().AimbotConfig.Slash.Prediction,
    Flag = "PredictionSlash",
    Callback = function(Value)
        getgenv().AimbotConfig.Slash.Prediction = Value
    end,
})
Aimbot:CreateSection("Chance")
getgenv().ping = game.Players.LocalPlayer:GetNetworkPing()
getgenv().Players = game:GetService("Players")
getgenv().RunService = game:GetService("RunService")
getgenv().UserInputService = game:GetService("UserInputService")
getgenv().Stats = game:GetService("Stats")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().LocalPlayer = Players.LocalPlayer
getgenv().PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
getgenv().StarterGui = game:GetService("StarterGui")
getgenv().shooting = false
getgenv().useCustomAnim = false
getgenv().loadedCustomAnimTrack = nil
getgenv().predictionBox = 4
getgenv().active = false
getgenv().usePingMode = false
getgenv().aimDuration = 1.7
getgenv().aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli"}
getgenv().spinDuration = 0.5
getgenv().delayDuration = 3
getgenv().usePingDelay = false
getgenv().Humanoid, getgenv().HRP = nil, nil
getgenv().lastTriggerTime = 0
getgenv().aiming = false
getgenv().originalWS, getgenv().originalJP, getgenv().originalAutoRotate = nil, nil, nil
getgenv().aimMode = "Normal"
getgenv().prevFlintVisibleAim = false
getgenv().prevFlintVisibleShoot = false
getgenv().movementThreshold = 0.5
getgenv().predictionMode = "Infront HRP"
getgenv().getValidTarget = function()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(aimTargets) do
            local target = killersFolder:FindFirstChild(name)
            if target and target:FindFirstChild("HumanoidRootPart") then
                return target.HumanoidRootPart, target:FindFirstChild("Humanoid")
            end
        end
    end
    return nil, nil
end
getgenv().setupCharacter = function(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end
if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)
getgenv().getPingSeconds = function()
    local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
    if pingStat then
        return pingStat:GetValue() / 1000
    end
    return 0.1
end
getgenv().getPredictedAimPosPing = function(targetHRP, killerHumanoid)
    local ping = getPingSeconds()
    local velocity = targetHRP.Velocity
    if velocity.Magnitude <= movementThreshold then
        return targetHRP.Position
    end
    return targetHRP.Position + (velocity * ping)
end
getgenv().getPredictedAimPosInfrontHRPPing = function(targetHRP)
    local ping = getPingSeconds()
    local studs = ping * 60
    if targetHRP.Velocity.Magnitude <= movementThreshold then
        return targetHRP.Position
    end
    return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
end
getgenv().isFlintlockVisible = function()
    if not LocalPlayer.Character then return false end
    local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
    if not flint then return false end
    if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
        flint = flint:FindFirstChildWhichIsA("BasePart", true)
        if not flint then return false end
    end
    if flint.Transparency >= 1 then
        return false
    end
    return true
end
RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end
    local isVisible = isFlintlockVisible()
    if isVisible and not prevFlintVisibleAim and not aiming then
        lastTriggerTime = tick()
        aiming = true
    elseif not isVisible and aiming and aimMode ~= "Delay Duration Aim" then
        aiming = false
        if originalWS and originalJP and originalAutoRotate ~= nil then
            Humanoid.WalkSpeed = originalWS
            Humanoid.JumpPower = originalJP
            Humanoid.AutoRotate = originalAutoRotate
            originalWS, originalJP, originalAutoRotate = nil, nil, nil
        end
    end
    prevFlintVisibleAim = isVisible
    if aiming then
        local elapsed = tick() - lastTriggerTime
        local adjustedDelay = usePingDelay and aimMode == "Delay Duration Aim" and (delayDuration + getPingSeconds()) or delayDuration
        if aimMode == "360" then
            if elapsed <= spinDuration then
                local spinProgress = elapsed / spinDuration
                local spinAngle = math.rad(360 * spinProgress)
                HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0)
            elseif elapsed <= spinDuration + 0.7 then
                if not originalWS then
                    originalWS = Humanoid.WalkSpeed
                    originalJP = Humanoid.JumpPower
                    originalAutoRotate = Humanoid.AutoRotate
                end
                Humanoid.AutoRotate = false
                HRP.AssemblyAngularVelocity = Vector3.zero
                local targetHRP, killerHumanoid = getValidTarget()
                if targetHRP then
                    local aimPos
                    if predictionMode == "Ping" then
                        aimPos = getPredictedAimPosPing(targetHRP, killerHumanoid)
                    elseif predictionMode == "Infront HRP" then
                        local studs = tonumber(predictionBox) or 0
                        if targetHRP.Velocity.Magnitude > movementThreshold then
                            aimPos = targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
                        else
                            aimPos = targetHRP.Position
                        end
                    elseif predictionMode == "Infront HRP (Ping Adjust)" then
                        aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                    else
                        local prediction = tonumber(predictionBox) or 0
                        if targetHRP.Velocity.Magnitude <= movementThreshold then
                            aimPos = targetHRP.Position
                        else
                            aimPos = targetHRP.Position + (targetHRP.Velocity * (prediction / 60))
                        end
                    end
                    if aimPos then
                        local direction = (aimPos - HRP.Position).Unit
                        local yRot = math.atan2(-direction.X, -direction.Z)
                        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                    end
                end
            else
                aiming = false
                if originalWS and originalJP and originalAutoRotate ~= nil then
                    Humanoid.WalkSpeed = originalWS
                    Humanoid.JumpPower = originalJP
                    Humanoid.AutoRotate = originalAutoRotate
                    originalWS, originalJP, originalAutoRotate = nil, nil, nil
                end
            end
        elseif aimMode == "Delay Duration Aim" then
            if elapsed >= adjustedDelay + 0.5 and elapsed <= adjustedDelay + 1 then
                if not originalWS then
                    originalWS = Humanoid.WalkSpeed
                    originalJP = Humanoid.JumpPower
                    originalAutoRotate = Humanoid.AutoRotate
                end
                Humanoid.AutoRotate = false
                HRP.AssemblyAngularVelocity = Vector3.zero
                local targetHRP, killerHumanoid = getValidTarget()
                if targetHRP then
                    local aimPos
                    if predictionMode == "Ping" then
                        aimPos = getPredictedAimPosPing(targetHRP, killerHumanoid)
                    elseif predictionMode == "Infront HRP" then
                        local studs = tonumber(predictionBox) or 0
                        if targetHRP.Velocity.Magnitude > movementThreshold then
                            aimPos = targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
                        else
                            aimPos = targetHRP.Position
                        end
                    elseif predictionMode == "Infront HRP (Ping Adjust)" then
                        aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                    else
                        local prediction = tonumber(predictionBox) or 0
                        if targetHRP.Velocity.Magnitude <= movementThreshold then
                            aimPos = targetHRP.Position
                        else
                            aimPos = targetHRP.Position + (targetHRP.Velocity * (prediction / 60))
                        end
                    end
                    if aimPos then
                        local direction = (aimPos - HRP.Position).Unit
                        local yRot = math.atan2(-direction.X, -direction.Z)
                        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                    end
                end
            elseif elapsed > adjustedDelay + 0.5 then
                aiming = false
                if originalWS and originalJP and originalAutoRotate ~= nil then
                    Humanoid.WalkSpeed = originalWS
                    Humanoid.JumpPower = originalJP
                    Humanoid.AutoRotate = originalAutoRotate
                    originalWS, originalJP, originalAutoRotate = nil, nil, nil
                end
            end
        else
            if elapsed <= aimDuration then
                if not originalWS then
                    originalWS = Humanoid.WalkSpeed
                    originalJP = Humanoid.JumpPower
                    originalAutoRotate = Humanoid.AutoRotate
                end
                Humanoid.AutoRotate = false
                HRP.AssemblyAngularVelocity = Vector3.zero
                local targetHRP, killerHumanoid = getValidTarget()
                if targetHRP then
                    local aimPos
                    if predictionMode == "Ping" then
                        aimPos = getPredictedAimPosPing(targetHRP, killerHumanoid)
                    elseif predictionMode == "Infront HRP" then
                        local studs = tonumber(predictionBox) or 0
                        if targetHRP.Velocity.Magnitude > movementThreshold then
                            aimPos = targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
                        else
                            aimPos = targetHRP.Position
                        end
                    elseif predictionMode == "Infront HRP (Ping Adjust)" then
                        aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                    else
                        local prediction = tonumber(predictionBox) or 0
                        if targetHRP.Velocity.Magnitude <= movementThreshold then
                            aimPos = targetHRP.Position
                        else
                            aimPos = targetHRP.Position + (targetHRP.Velocity * (prediction / 60))
                        end
                    end
                    if aimPos then
                        local direction = (aimPos - HRP.Position).Unit
                        local yRot = math.atan2(-direction.X, -direction.Z)
                        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                    end
                end
            else
                aiming = false
                if originalWS and originalJP and originalAutoRotate ~= nil then
                    Humanoid.WalkSpeed = originalWS
                    Humanoid.JumpPower = originalJP
                    Humanoid.AutoRotate = originalAutoRotate
                    originalWS, originalJP, originalAutoRotate = nil, nil, nil
                end
            end
        end
    end
end)
RunService.RenderStepped:Connect(function()
    local isVisible = isFlintlockVisible()
    if isVisible and not prevFlintVisibleShoot and not shooting then
        lastTriggerTime = tick()
        shooting = true
    end
    prevFlintVisibleShoot = isVisible
    if shooting then
        shooting = false
    end
end)
Aimbot:CreateToggle({
    Name = "Aimbot One Shot",
    CurrentValue = false,
    Flag = "ChanceAim",
    Callback = function(value)
        active = value
    end,
})
Aimbot:CreateInput({
    Name = "Prediction One Shot",
    PlaceholderText = "4",
    RemoveTextAfterFocusLost = false,
    Flag = "PredictionBox",
    Callback = function(text)
        predictionBox = tonumber(text) or 0
    end,
})
Aimbot:CreateDropdown({
    Name = "Prediction Mode One Shot",
    Options = {"Velocity","Ping","Infront HRP","Infront HRP (Ping Adjust)"},
    CurrentOption = {"Infront HRP"},
    Flag = "PredictionMode",
    Callback = function(option)
        predictionMode = option[1]
    end,
})
Aimbot:CreateDropdown({
    Name = "Aim Behavior Mode One Shot",
    Options = {"Normal","360","Delay Duration Aim"},
    CurrentOption = {"Normal"},
    Flag = "AimMode",
    Callback = function(option)
        aimMode = option[1]
    end,
})
Aimbot:CreateInput({
    Name = "Spin Speed One Shot (360)",
    PlaceholderText = "0.5",
    RemoveTextAfterFocusLost = false,
    Flag = "SpinSpeed",
    Callback = function(text)
        spinDuration = tonumber(text) or 0.5
    end,
})
Aimbot:CreateInput({
    Name = "Delay Duration One Shot",
    PlaceholderText = "3",
    RemoveTextAfterFocusLost = false,
    Flag = "DelayDuration",
    Callback = function(text)
        delayDuration = tonumber(text) or 3
    end,
})
Aimbot:CreateToggle({
    Name = "Ping Check Mode for Delay Duration",
    CurrentValue = false,
    Flag = "PingDelayMode",
    Callback = function(value)
        usePingDelay = value
    end,
})
Aimbot:CreateSection("Guest 1337 -- Punch")
Aimbot:CreateToggle({
    Name = "Aimbot Punch",
    CurrentValue = getgenv().AimbotConfig.Punch.Enabled,
    Flag = "AutoAimPunch",
    Callback = function(Value)
        getgenv().AimbotConfig.Punch.Enabled = Value
    end,
})
Aimbot:CreateSlider({
    Name = "Smoothness Punch",
    Range = {0, 101},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = getgenv().AimbotConfig.Punch.Smoothness * 100,
    Flag = "SmoothnessPunch",
    Callback = function(Value)
        getgenv().AimbotConfig.Punch.Smoothness = Value / 100
    end,
})
Aimbot:CreateSlider({
    Name = "Prediction Punch",
    Range = {0, 2},
    Increment = 0.05,
    Suffix = "s",
    CurrentValue = getgenv().AimbotConfig.Punch.Prediction,
    Flag = "PredictionPunch",
    Callback = function(Value)
        getgenv().AimbotConfig.Punch.Prediction = Value
    end,
})
Aimbot:CreateSection("Guest 1337 -- Charge")
Aimbot:CreateToggle({
    Name = "Aimbot Charge",
    CurrentValue = getgenv().AimbotConfig.Charge.Enabled,
    Flag = "AutoAimCharge",
    Callback = function(Value)
        getgenv().AimbotConfig.Charge.Enabled = Value
    end,
})
Aimbot:CreateSlider({
    Name = "Smoothness Charge",
    Range = {0, 101},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = getgenv().AimbotConfig.Charge.Smoothness * 100,
    Flag = "SmoothnessCharge",
    Callback = function(Value)
        getgenv().AimbotConfig.Charge.Smoothness = Value / 100
    end,
})
Aimbot:CreateSlider({
    Name = "Prediction Charge",
    Range = {0, 2},
    Increment = 0.05,
    Suffix = "s",
    CurrentValue = getgenv().AimbotConfig.Charge.Prediction,
    Flag = "PredictionCharge",
    Callback = function(Value)
        getgenv().AimbotConfig.Charge.Prediction = Value
    end,
})
Aimbot:CreateSection("Elliot")
Aimbot:CreateToggle({
    Name = "Aimbot Throw Pizza",
    CurrentValue = getgenv().AimbotConfig.ThrowPizza.Enabled,
    Flag = "AutoAimThrowPizza",
    Callback = function(Value)
        getgenv().AimbotConfig.ThrowPizza.Enabled = Value
    end,
})
Aimbot:CreateSlider({
    Name = "Smoothness Throw Pizza",
    Range = {0, 101},
    Increment = 1,
    Suffix = "ms",
    CurrentValue = getgenv().AimbotConfig.ThrowPizza.Smoothness * 100,
    Flag = "SmoothnessThrowPizza",
    Callback = function(Value)
        getgenv().AimbotConfig.ThrowPizza.Smoothness = Value / 100
    end,
})
Aimbot:CreateSlider({
    Name = "Prediction Throw Pizza",
    Range = {0, 2},
    Increment = 0.2,
    Suffix = "s",
    CurrentValue = getgenv().AimbotConfig.ThrowPizza.Prediction,
    Flag = "PredictionThrowPizza",
    Callback = function(Value)
        getgenv().AimbotConfig.ThrowPizza.Prediction = Value
    end,
})
Aimbot:CreateSection("Killers")
Aimbot:CreateToggle({
    Name = "Killers's Aimbot",
    CurrentValue = getgenv().AimbotConfig.Killers.Enabled,
    Flag = "EnableAimbotAll",
    Callback = function(Value)
        getgenv().AimbotConfig.Killers.Enabled = Value
    end,
})
Aimbot:CreateSection("AimMode")
Aimbot:CreateDropdown({
    Name = "Aim Mode",
    Options = {"Aimbot", "RootPart"},
    CurrentOption = getgenv().AimbotConfig.Mode,
    Flag = "AimModeSelect",
    Callback = function(Value)
        getgenv().AimbotConfig.Mode = Value[1]
    end,
})
local staminaLoopToggle = false
local maxStamina = 100
local minStamina = 0
local staminaGain = 20
local staminaLoss = 10
local sprintSpeed = 26
local staminaLossDisabled = false
StaminaSet:CreateToggle({
   Name = "Inj3ct Stamina",
   CurrentValue = false,
   Flag = "StaminaLoopToggle",
   Callback = function(Value)
      staminaLoopToggle = Value
   end,
})
StaminaSet:CreateInput({
   Name = "Max Stamina",
   PlaceholderText = "e.g. 100",
   CurrentValue = tostring(maxStamina),
   RemoveTextAfterFocusLost = false,
   Flag = "MaxStaminaInput",
   Callback = function(Text)
      maxStamina = tonumber(Text) or maxStamina
   end,
})
StaminaSet:CreateInput({
   Name = "Min Stamina",
   PlaceholderText = "e.g. 0",
   CurrentValue = tostring(minStamina),
   RemoveTextAfterFocusLost = false,
   Flag = "MinStaminaInput",
   Callback = function(Text)
      minStamina = tonumber(Text) or minStamina
   end,
})
StaminaSet:CreateInput({
   Name = "Stamina Gain",
   PlaceholderText = "e.g. 10",
   CurrentValue = tostring(staminaGain),
   RemoveTextAfterFocusLost = false,
   Flag = "StaminaGainInput",
   Callback = function(Text)
      staminaGain = tonumber(Text) or staminaGain
   end,
})
StaminaSet:CreateInput({
   Name = "Stamina Loss",
   PlaceholderText = "e.g. 10",
   CurrentValue = tostring(staminaLoss),
   RemoveTextAfterFocusLost = false,
   Flag = "StaminaLossInput",
   Callback = function(Text)
      staminaLoss = tonumber(Text) or staminaLoss
   end,
})
StaminaSet:CreateInput({
   Name = "Sprint Speed",
   PlaceholderText = "e.g. 26",
   CurrentValue = tostring(sprintSpeed),
   RemoveTextAfterFocusLost = false,
   Flag = "SprintSpeedInput",
   Callback = function(Text)
      sprintSpeed = tonumber(Text) or sprintSpeed
   end,
})
StaminaSet:CreateToggle({
   Name = "Disable Stamina Loss",
   CurrentValue = false,
   Flag = "ToggleStaminaLossDisabled",
   Callback = function(Value)
      staminaLossDisabled = Value
   end,
})
task.spawn(function()
   local Sprinting = game:GetService("ReplicatedStorage"):WaitForChild("Systems"):WaitForChild("Character"):WaitForChild("Game"):WaitForChild("Sprinting")
   local stamina = require(Sprinting)
   local defaultValues = {
      MaxStamina = 100,
      MinStamina = 0,
      StaminaGain = 20,
      StaminaLoss = 10,
      SprintSpeed = 26,
   }
   while task.wait() do
      if staminaLoopToggle then
         stamina.MaxStamina = maxStamina
         stamina.MinStamina = minStamina
         stamina.StaminaGain = staminaGain
         stamina.StaminaLoss = staminaLoss
         stamina.SprintSpeed = sprintSpeed
         stamina.StaminaLossDisabled = staminaLossDisabled
      else
         stamina.MaxStamina = defaultValues.MaxStamina
         stamina.MinStamina = defaultValues.MinStamina
         stamina.StaminaGain = defaultValues.StaminaGain
         stamina.StaminaLoss = defaultValues.StaminaLoss
         stamina.SprintSpeed = defaultValues.SprintSpeed
         stamina.StaminaLossDisabled = false
      end
   end
end)
local Survivors = workspace:WaitForChild("Players"):WaitForChild("Survivors")
local AntiSlowConfigs = {
    Slowness = {Values = {"SlowedStatus"}, Connection = nil, Enabled = false},
    Skills = {Values = {"StunningKiller", "EatFriedChicken", "GuestBlocking", "PunchAbility", "SubspaceTripmine",
                        "TaphTripwire", "PlasmaBeam", "SpawnProtection", "c00lgui", "ShootingGun",
                        "TwoTimeStab", "TwoTimeCrouching", "DrinkingCola", "DrinkingSlateskin",
                        "SlateskinStatus", "EatingGhostburger"}, Connection = nil, Enabled = false},
    Items = {Values = {"BloxyColaItem", "Medkit"}, Connection = nil, Enabled = false},
    Emotes = {Values = {"Emoting"}, Connection = nil, Enabled = false},
    Builderman = {Values = {"DispenserConstruction", "SentryConstruction"}, Connection = nil, Enabled = false}
}
local function hideSlownessUI()
    local mainUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("MainUI")
    if mainUI then
        local statusContainer = mainUI:FindFirstChild("StatusContainer")
        if statusContainer then
            local slownessUI = statusContainer:FindFirstChild("Slowness")
            if slownessUI then
                slownessUI.Visible = false
            end
        end
    end
end
local function handleAntiSlow(survivor, config)
    if survivor:GetAttribute("Username") ~= game:GetService("Players").LocalPlayer.Name then return end
    local function onRenderStep()
        if not survivor.Parent or not config.Enabled then return end
        local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
        if speedMultipliers then
            for _, valName in ipairs(config.Values) do
                local val = speedMultipliers:FindFirstChild(valName)
                if val and val:IsA("NumberValue") and val.Value ~= 1 then
                    val.Value = 1
                end
            end
        end
        hideSlownessUI()
    end
    config.Connection = RunService.RenderStepped:Connect(onRenderStep)
end
local function startAntiSlow(config)
    config.Enabled = true
    for _, survivor in pairs(Survivors:GetChildren()) do
        handleAntiSlow(survivor, config)
    end
    Survivors.ChildAdded:Connect(function(child)
        task.wait(0.1)
        handleAntiSlow(child, config)
    end)
end
local function stopAntiSlow(config)
    config.Enabled = false
    if config.Connection then
        config.Connection:Disconnect()
        config.Connection = nil
    end
end
for name, config in pairs(AntiSlowConfigs) do
    AntiSlows:CreateToggle({
        Name = "Anti-Slow " .. name,
        CurrentValue = false,
        Flag = "AntiSlow" .. name,
        Callback = function(value)
            if value then
                startAntiSlow(config)
            else
                stopAntiSlow(config)
            end
        end
    })
end
getgenv().Players = game:GetService("Players")
getgenv().LocalPlayer = getgenv().Players.LocalPlayer
getgenv().Remote = game:GetService("ReplicatedStorage").Modules.Network.RemoteEvent
local globalEnv = getgenv()
globalEnv.Players = game:GetService("Players")
globalEnv.RunService = game:GetService("RunService")
globalEnv.Camera = workspace.CurrentCamera
globalEnv.Player = globalEnv.Players.LocalPlayer
globalEnv.walkSpeed = 100
globalEnv.toggle = false
globalEnv.connection = nil
function globalEnv.getCharacter()
    return globalEnv.Player.Character or globalEnv.Player.CharacterAdded:Wait()
end
function globalEnv.onHeartbeat()
    local player = globalEnv.Player
    local character = globalEnv.getCharacter()
    if character.Name ~= "c00lkidd" then return end
    local char = globalEnv.getCharacter()
    local rootPart = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local lv = rootPart and rootPart:FindFirstChild("LinearVelocity")
    if not rootPart or not humanoid or not lv then return end
    if lv then
        lv.VectorVelocity = Vector3.new(math.huge, math.huge, math.huge)
        lv.Enabled = false
    end
local stopMovement = false
local validValues = {
    Timeout = true,
    Collide = true,
    Hit = true
}
local function watchResult(result)
    local function checkValue()
        if validValues[result.Value] then
            stopMovement = true
        end
    end
    checkValue()
    result:GetPropertyChangedSignal("Value"):Connect(checkValue)
end
local function onCharacterAdded(character)
    local result = character:FindFirstChild("Result")
    if result and result:IsA("StringValue") then
        watchResult(result)
    end
    character.ChildAdded:Connect(function(child)
        if child.Name == "Result" and child:IsA("StringValue") then
            watchResult(child)
        end
    end)
end
Player.CharacterAdded:Connect(onCharacterAdded)
if Player.Character then
    onCharacterAdded(Player.Character)
end
    if not stopMovement then
        local lookVector = globalEnv.Camera.CFrame.LookVector
        local moveDir = Vector3.new(lookVector.X, 0, lookVector.Z)
        if moveDir.Magnitude > 0 then
            moveDir = moveDir.Unit
            rootPart.Velocity = Vector3.new(moveDir.X * globalEnv.walkSpeed, rootPart.Velocity.Y, moveDir.Z * globalEnv.walkSpeed)
            rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + moveDir)
        end
    end
end
if not getgenv().originalNamecall then
    getgenv().HookRules = {}
    getgenv().originalNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if method == "FireServer" then
            for _, rule in ipairs(getgenv().HookRules) do
                if (not rule.remoteName or self.Name == rule.remoteName) then
                    if not rule.blockedFirstArg or args[1] == rule.blockedFirstArg then
                        if rule.block then
                            return
                        end
                    end
                end
            end
        end
        return getgenv().originalNamecall(self, ...)
    end)
end
getgenv().activateRemoteHook = function(remoteName, blockedFirstArg)
    for _, rule in ipairs(getgenv().HookRules) do
        if rule.remoteName == remoteName and rule.blockedFirstArg == blockedFirstArg then
            return
        end
    end
    table.insert(getgenv().HookRules, {
        remoteName = remoteName,
        blockedFirstArg = blockedFirstArg,
        block = true
    })
end
getgenv().deactivateRemoteHook = function(remoteName, blockedFirstArg)
    for i, rule in ipairs(getgenv().HookRules) do
        if rule.remoteName == remoteName and rule.blockedFirstArg == blockedFirstArg then
            table.remove(getgenv().HookRules, i)
            break
        end
    end
end
getgenv().EnableC00lkidd = function()
    getgenv().activateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "C00lkiddCollision")
end
getgenv().DisableC00lkidd = function()
    getgenv().deactivateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "C00lkiddCollision")
end
getgenv().EnableVoidRush = function()
    getgenv().activateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "VoidRushCollision")
end
getgenv().DisableVoidRush = function()
    getgenv().deactivateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "VoidRushCollision")
end
getgenv().EnableCharge = function()
    getgenv().activateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "Guest1337Collision")
end
getgenv().DisableCharge = function()
    getgenv().deactivateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "Guest1337Collision")
end
getgenv().isFiringDusekkar = false
getgenv().EnableProtection = function()
    getgenv().activateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "DusekkarCancel")
    if not getgenv().isFiringDusekkar then
        getgenv().isFiringDusekkar = true
        task.spawn(function()
            task.wait(4)
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
            RemoteEvent:FireServer({game.Players.LocalPlayer.Name .. "DusekkarCancel"})
            getgenv().isFiringDusekkar = false
        end)
    end
end
getgenv().DisableProtection = function()
    getgenv().deactivateRemoteHook("RemoteEvent", game.Players.LocalPlayer.Name .. "DusekkarCancel")
end
getgenv().blockFootstepPlayed = false
getgenv().HookFootstepPlayed = function(enable)
    if enable then
        getgenv().activateRemoteHook("UnreliableRemoteEvent", "FootstepPlayed")
        getgenv().blockFootstepPlayed = true
    else
        getgenv().deactivateRemoteHook("UnreliableRemoteEvent", "FootstepPlayed")
        getgenv().blockFootstepPlayed = false
    end
end
Combat:CreateSection("c00lkidd")
Combat:CreateToggle({
    Name = "Walkspeed Override Controller",
    CurrentValue = false,
    Flag = "AutoMove",
    Callback = function(value)
        if value then
            globalEnv.connection = globalEnv.RunService.Heartbeat:Connect(globalEnv.onHeartbeat)
        else
            if globalEnv.connection then
                globalEnv.connection:Disconnect()
            end
        end
    end
})
Combat:CreateToggle({
    Name = "Walkspeed-Override Ignore Objectables",
    CurrentValue = false,
    Flag = "IgnoreC00lkidd",
    Callback = function(Value)
        if Value then
            getgenv().EnableC00lkidd()
        else
            getgenv().DisableC00lkidd()
        end
    end
})
local VoidRushController = {}
VoidRushController.Toggle = false
VoidRushController.OriginalDashSpeed = 60
VoidRushController.IsActive = false
VoidRushController.DashConnection = nil
VoidRushController.CheckThread = nil
VoidRushController.KillerConn = nil
local Player = game.Players.LocalPlayer
local RunService = game:GetService("RunService")
local function updateCharacter()
    VoidRushController.Character = Player.Character or Player.CharacterAdded:Wait()
    VoidRushController.Humanoid = VoidRushController.Character:WaitForChild("Humanoid")
    VoidRushController.HumanoidRootPart = VoidRushController.Character:WaitForChild("HumanoidRootPart")
end
updateCharacter()
Player.CharacterAdded:Connect(function()
    updateCharacter()
    VoidRushController:Stop()
end)
function VoidRushController:Start()
    if self.IsActive then return end
    self.IsActive = true
    self.DashConnection = RunService.RenderStepped:Connect(function()
        if not self.Humanoid or not self.HumanoidRootPart then return end
        self.Humanoid.WalkSpeed = self.OriginalDashSpeed
        self.Humanoid.AutoRotate = false
        local dir = self.HumanoidRootPart.CFrame.LookVector
        local horizontalDir = Vector3.new(dir.X, 0, dir.Z).Unit
        self.Humanoid:Move(horizontalDir)
    end)
end
function VoidRushController:Stop()
    if not self.IsActive then return end
    self.IsActive = false
    if self.Humanoid then
        self.Humanoid.WalkSpeed = 16
        self.Humanoid.AutoRotate = true
        self.Humanoid:Move(Vector3.new(0,0,0))
    end
    if self.DashConnection then
        self.DashConnection:Disconnect()
        self.DashConnection = nil
    end
end
function VoidRushController:FullCleanup()
    self:Stop()
    if self.KillerConn then
        self.KillerConn:Disconnect()
        self.KillerConn = nil
    end
    if self.CheckThread then
        task.cancel(self.CheckThread)
        self.CheckThread = nil
    end
end
function VoidRushController:CheckVoidRush()
    self.CheckThread = task.spawn(function()
        while self.Toggle do
            local KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
            local noliKiller = nil
            for _, killer in ipairs(KillersFolder:GetChildren()) do
                if killer:GetAttribute("Username") == Player.Name
                and killer:GetAttribute("ActorDisplayName") == "Noli" then
                    noliKiller = killer
                    break
                end
            end
            if noliKiller then
                local function updateState()
                    if not self.Toggle then
                        self:Stop()
                        return
                    end
                    if noliKiller:GetAttribute("VoidRushState") == "Dashing" then
                        self:Start()
                    else
                        self:Stop()
                    end
                end
                updateState()
                self.KillerConn = noliKiller:GetAttributeChangedSignal("VoidRushState"):Connect(updateState)
                noliKiller.AncestryChanged:Wait()
                if self.KillerConn then
                    self.KillerConn:Disconnect()
                    self.KillerConn = nil
                end
                self:Stop()
            else
                task.wait(0.1)
            end
        end
    end)
end
Combat:CreateSection("Noli")
Combat:CreateToggle({
    Name = "Void Rush Controller",
    Flag = "VoidRushController",
    CurrentValue = false,
    Callback = function(value)
        VoidRushController.Toggle = value
        if value then
            VoidRushController:CheckVoidRush()
        else
            VoidRushController:FullCleanup()
        end
    end,
})
Combat:CreateToggle({
    Name = "Void-Rush Ignore Objectables",
    CurrentValue = false,
    Flag = "IgnoreVoidRush",
    Callback = function(Value)
        if Value then
            getgenv().EnableVoidRush()
        else
            getgenv().DisableVoidRush()
        end
    end
})
Combat:CreateSection("Dusekkar")
Combat:CreateToggle({
    Name = "Anti-Cancelled Protection",
    CurrentValue = false,
    Flag = "ProtectionDusekkar",
    Callback = function(Value)
        if Value then
            getgenv().EnableProtection()
        else
            getgenv().DisableProtection()
        end
    end
})
getgenv().Lighting = game:GetService("Lighting")
getgenv().Workspace = game:GetService("Workspace")
getgenv().removeEffectsEnabled = false
getgenv().lightingConnection = nil
getgenv().workspaceConnection = nil
getgenv().lightingTargets = {
    "BlindnessBlur",
    "SubspaceVFXBlur",
    "SubspaceVFXColorCorrection"
}
getgenv().workspaceTargets = {
    "GlitchParts"
}
getgenv().removeLightingInstances = function()
    for _, name in ipairs(getgenv().lightingTargets) do
        local obj = getgenv().Lighting:FindFirstChild(name)
        if obj then
            obj:Destroy()
        end
    end
end
getgenv().removeWorkspaceInstances = function()
    for _, name in ipairs(getgenv().workspaceTargets) do
        local obj = getgenv().Workspace:FindFirstChild(name)
        if obj then
            obj:Destroy()
        end
    end
end
getgenv().enableRemoveEffects = function()
    getgenv().removeLightingInstances()
    getgenv().removeWorkspaceInstances()
    getgenv().lightingConnection = getgenv().Lighting.ChildAdded:Connect(function(child)
        if table.find(getgenv().lightingTargets, child.Name) then
            child:Destroy()
        end
    end)
    getgenv().workspaceConnection = getgenv().Workspace.ChildAdded:Connect(function(child)
        if table.find(getgenv().workspaceTargets, child.Name) then
            child:Destroy()
        end
    end)
    getgenv().removeEffectsEnabled = true
end
getgenv().disableRemoveEffects = function()
    if getgenv().lightingConnection then
        getgenv().lightingConnection:Disconnect()
        getgenv().lightingConnection = nil
    end
    if getgenv().workspaceConnection then
        getgenv().workspaceConnection:Disconnect()
        getgenv().workspaceConnection = nil
    end
    getgenv().removeEffectsEnabled = false
end
Combat:CreateSection("Blindness")
Combat:CreateToggle({
    Name = "Anti Blindness",
    CurrentValue = false,
    Flag = "RemoveBlindness",
    Callback = function(value)
        if value then
            getgenv().enableRemoveEffects()
        else
            getgenv().disableRemoveEffects()
        end
    end
})
local function getRerollGui()
    local success, gui = pcall(function()
        return game:GetService("Players").LocalPlayer.PlayerGui:WaitForChild("MainUI", 5)
            :WaitForChild("AbilityContainer", 5)
            :WaitForChild("Reroll", 5)
    end)
    return success and gui or nil
end
local AutoCoinFlip = false
local MaxCharges = 3
local Delay = 0.25
Combat:CreateSection("Chance")
Combat:CreateToggle({
    Name = "Auto CoinFlip",
    CurrentValue = false,
    Flag = "AutoCoinFlip",
    Callback = function(value)
        AutoCoinFlip = value
    end
})
Combat:CreateSlider({
    Name = "Charges",
    Range = {1, 3},
    Increment = 1,
    Suffix = "charges",
    CurrentValue = MaxCharges,
    Flag = "MaxChargesSlider",
    Callback = function(value)
        MaxCharges = value
    end
})
spawn(function()
    while true do
        local gui = getRerollGui()
        if gui then
            local chargesLabel = gui:FindFirstChild("Charges")
            local currentCharges = chargesLabel and tonumber(chargesLabel.Text) or 0
            if AutoCoinFlip and currentCharges < MaxCharges then
                local ok, err = pcall(function()
					RemoteEvent:FireServer("UseActorAbility", {buffer.fromstring("\"CoinFlip\"")})
                end)
                if not ok then
                    warn("CoinFlip failed:", err)
                end
            end
        end
        wait(Delay)
    end
end)
getgenv().StorageReplicated = game:GetService("ReplicatedStorage")
getgenv().NetworkRemote = getgenv().StorageReplicated:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
getgenv().MainRemote = getgenv().NetworkRemote
getgenv().baseHooks = {}
getgenv().currentHooks = {}
getgenv().initHook = function(targetRemote)
    getgenv().originalHookFunction = hookmetamethod(game, "__namecall", function(self, ...)
        getgenv().methodCalled = getnamecallmethod()
        getgenv().parameters = {...}
        if self == getgenv().MainRemote and getgenv().methodCalled == "FireServer" then
            if type(getgenv().parameters[1]) == "string" and getgenv().parameters[1]:find(game.Players.LocalPlayer.Name) and getgenv().parameters[1]:find(targetRemote) then
                if #getgenv().parameters >= 2 and typeof(getgenv().parameters[2]) == "Vector3" then
                    getgenv().camera = workspace.CurrentCamera
                    getgenv().parameters[2] = getgenv().camera.CFrame.LookVector
                    return getgenv().baseHooks[targetRemote](self, unpack(getgenv().parameters))
                end
                return
            end
        end
        return getgenv().baseHooks[targetRemote](self, ...)
    end)
    getgenv().baseHooks[targetRemote] = getgenv().originalHookFunction
    return getgenv().originalHookFunction
end
getgenv().activateHook = function(targetRemote)
    if not getgenv().currentHooks[targetRemote] then
        getgenv().currentHooks[targetRemote] = getgenv().initHook(targetRemote)
    end
end
getgenv().deactivateHook = function(targetRemote)
    if getgenv().currentHooks[targetRemote] and getgenv().baseHooks[targetRemote] then
        hookmetamethod(game, "__namecall", getgenv().baseHooks[targetRemote])
        getgenv().currentHooks[targetRemote] = nil
        getgenv().baseHooks[targetRemote] = nil
    end
end
Combat:CreateToggle({
    Name = "Chance True One Shot",
    CurrentValue = false,
    Flag = "ChanceTrueShoot",
    Callback = function(value)
        if value then
            getgenv().activateHook("ChanceFireShot")
        else
            getgenv().deactivateHook("ChanceFireShot")
        end
    end
})
local getgenv = getgenv or function() return _G end
getgenv().Players = game:GetService("Players")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().player = getgenv().Players.LocalPlayer
getgenv().remote = getgenv().ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
if not getgenv().remote or getgenv().remote.ClassName ~= "RemoteEvent" then
    return
end
getgenv().blockEnabled = true
getgenv().blockedName = getgenv().player.Name .. "ChanceFireShot"
getgenv().delayDuration = 3
getgenv().mt = getrawmetatable(game)
getgenv().oldNamecall = getgenv().mt.__namecall
setreadonly(getgenv().mt, false)
getgenv().mt.__namecall = function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    if getgenv().blockEnabled and method == "FireServer" then
        local firstArg = args[1]
        if type(firstArg) == "string" and firstArg == getgenv().blockedName then
            task.delay(getgenv().delayDuration, function()
                getgenv().blockEnabled = false
                local character = getgenv().player.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not rootPart then
                    getgenv().blockEnabled = true
                    return
                end
                local lookVector = rootPart.CFrame.LookVector
                local data = {
                    Vector3.new(lookVector.X, lookVector.Y, lookVector.Z)
                }
                getgenv().remote:FireServer(firstArg, data)
                getgenv().blockEnabled = true
            end)
            return
        end
    end
    return getgenv().oldNamecall(self, ...)
end
setreadonly(getgenv().mt, true)
Combat:CreateToggle({
    Name = "Storing Hitbox Gun",
    Flag = "StoringHitboxGun",
    CurrentValue = true,
    Callback = function(Value)
        getgenv().blockEnabled = Value
    end
})
Combat:CreateInput({
    Name = "Delay Duration (seconds)",
    Flag = "DelayDurationseconds",
    PlaceholderText = "2",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num > 0 then
            getgenv().delayDuration = num
        end
    end
})
local lp = Players.LocalPlayer
local isChargeActive = false
local connection = nil
local DEFAULT_WALK_SPEED = 16
local ORIGINAL_DASH_SPEED = 50
local chargecontrol = false
local function setupCharacter(character)
    local Humanoid = character:WaitForChild("Humanoid")
    local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    _G.Humanoid = Humanoid
    _G.HumanoidRootPart = HumanoidRootPart
    DEFAULT_WALK_SPEED = Humanoid.WalkSpeed
end
local function startCharge()
    if isChargeActive then return end
    isChargeActive = true
    connection = RunService.RenderStepped:Connect(function()
        if not _G.Humanoid or not _G.HumanoidRootPart then return end
        _G.Humanoid.WalkSpeed = ORIGINAL_DASH_SPEED
        _G.Humanoid.AutoRotate = false
        local direction = _G.HumanoidRootPart.CFrame.LookVector
        local horizontal = Vector3.new(direction.X, 0, direction.Z)
        if horizontal.Magnitude > 0 then
            _G.Humanoid:Move(horizontal.Unit)
        end
    end)
end
local function stopCharge()
    if not isChargeActive then return end
    isChargeActive = false
    if _G.Humanoid then
        _G.Humanoid.WalkSpeed = DEFAULT_WALK_SPEED
        _G.Humanoid.AutoRotate = true
        _G.Humanoid:Move(Vector3.new(0, 0, 0))
    end
    if connection then
        connection:Disconnect()
        connection = nil
    end
end
if lp.Character then
    setupCharacter(lp.Character)
end
lp.CharacterAdded:Connect(setupCharacter)
RunService.RenderStepped:Connect(function()
    if not chargecontrol then return end
    if not lp.Character then return end
    local speedMultipliers = lp.Character:FindFirstChild("SpeedMultipliers")
    if speedMultipliers then
        local charge = speedMultipliers:FindFirstChild("Guest1337Charge")
        if charge then
            startCharge()
        else
            stopCharge()
        end
    else
        stopCharge()
    end
end)
Combat:CreateSection("Guest 1337 -- Charge")
Combat:CreateToggle({
    Name = "Charge Controller",
    CurrentValue = false,
    Flag = "ChargeControlToggle",
    Callback = function(Value)
        toggled = Value
        if toggled then
            chargecontrol = true
        else
            chargecontrol = false
            stopCharge()
        end
    end
})
Combat:CreateToggle({
    Name = "Charge Ignore Objectables",
    CurrentValue = false,
    Flag = "IgnoreCharge",
    Callback = function(Value)
        if Value then
            getgenv().EnableCharge()
        else
            getgenv().DisableCharge()
        end
    end
})
getgenv().LocalPlayer = Players.LocalPlayer
getgenv().AutoBackstab = false
getgenv().StabDistance = 5
getgenv().TpBehind = 2.9
getgenv().Cooldown = false
Combat:CreateSection("Two Time")
Combat:CreateToggle({
    Name = "Auto Backstab",
    CurrentValue = false,
    Flag = "AutoBackstabToggle",
    Callback = function(Value)
        AutoBackstab = Value
    end,
})
Combat:CreateSlider({
    Name = "Stab Distance",
    Range = {2, 20},
    Increment = 0.1,
    Suffix = "studs",
    CurrentValue = StabDistance,
    Flag = "StabDistance",
    Callback = function(Value)
        StabDistance = Value
    end,
})
Combat:CreateSlider({
    Name = "TP Behind Distance",
    Range = {1, 6},
    Increment = 0.1,
    Suffix = "studs",
    CurrentValue = TpBehind,
    Flag = "TpBehind",
    Callback = function(Value)
        TpBehind = Value
    end,
})
local function isBehindTarget(target, distance)
    if not target or not target.Character then return false end
    local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
    local root = target.Character:FindFirstChild("HumanoidRootPart")
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not root or not myRoot then return false end
    if humanoid.MaxHealth <= 300 then return false end
    if (myRoot.Position - root.Position).Magnitude > distance then return false end
    local targetLook = root.CFrame.LookVector
    local toMe = (myRoot.Position - root.Position).Unit
    local dot = targetLook:Dot(toMe)
    return dot < -0.5, root
end
local function isDaggerReady()
    local mainUI = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
    if not mainUI then return false end
    local abilityContainer = mainUI:FindFirstChild("AbilityContainer")
    if not abilityContainer then return false end
    local dagger = abilityContainer:FindFirstChild("Dagger")
    if not dagger then return false end
    local cooldownLabel = dagger:FindFirstChild("CooldownTime")
    if not cooldownLabel then return false end
    return cooldownLabel.Text == ""
end
local function isHelplessReady()
    local player = game:GetService("Players").LocalPlayer
    local mainUI = player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild("MainUI")
    if not mainUI then return false end
    local statusContainer = mainUI:FindFirstChild("StatusContainer")
    if not statusContainer then return false end
    local helpless = statusContainer:FindFirstChild("Helpless")
    if not helpless then return false end
    return true
end
RunService.Heartbeat:Connect(function()
    if not AutoBackstab then return end
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local currentTime = tick()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local behind, root = isBehindTarget(plr, StabDistance)
            if behind and root then
                if isDaggerReady() and not isHelplessReady() then
                    if not getgenv().StabEndTime then
                        getgenv().StabEndTime = currentTime + 0.5
                    end
                end
                if getgenv().StabEndTime and currentTime <= getgenv().StabEndTime and not isHelplessReady() then
                    local newPos = root.Position - root.CFrame.LookVector * TpBehind
                    myRoot.CFrame = CFrame.new(newPos, root.Position)
                    if isDaggerReady() and not isHelplessReady() then
                        RemoteEvent:FireServer("UseActorAbility", {buffer.fromstring("\"Dagger\"")})
                    end
                    myRoot.CFrame = CFrame.new(newPos, root.Position)
                else
                    getgenv().StabEndTime = nil
                end
            end
        end
    end
end)
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().TweenService = game:GetService("TweenService")
getgenv().RunService = game:GetService("RunService")
getgenv().Players = game:GetService("Players")
getgenv().lp = Players.LocalPlayer
getgenv().PlayerGui = lp:WaitForChild("PlayerGui")
getgenv().Humanoid, getgenv().Animator = nil, nil
getgenv().autoBlockTriggerSounds = {
    ["102228729296384"] = true,
    ["140242176732868"] = true,
    ["112809109188560"] = true,
    ["136323728355613"] = true,
    ["115026634746636"] = true,
    ["84116622032112"] = true,
    ["108907358619313"] = true,
    ["127793641088496"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["119942598489800"] = true,
    ["84307400688050"] = true,
    ["113037804008732"] = true,
    ["105200830849301"] = true,
    ["75330693422988"] = true,
    ["82221759983649"] = true,
    ["81702359653578"] = true,
    ["108610718831698"] = true,
    ["112395455254818"] = true,
    ["136323728355613"] = true,
    ["81702359653578"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["109431876587852"] = true,
    ["115026634746636"] = true,
    ["119942598489800"] = true,
    ["109348678063422"] = true,
    ["85853080745515"] = true
}
getgenv().lastAimTrigger = {}
getgenv().AIM_WINDOW = 0.5
getgenv().AIM_COOLDOWN = 0.6
getgenv().autoBlockOn = false
getgenv().autoBlockAudioOn = false
getgenv().doubleblocktech = false
getgenv().looseFacing = false
getgenv().detectionRange = 18
getgenv().killerNames = {"c00lkidd", "Jason", "JohnDoe", "1x1x1x1", "Noli", "Slasher"}
getgenv().autoPunchOn = false
getgenv().autoFallPunchOn = false
getgenv().aimPunch = false
getgenv().KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
getgenv().blockAnimIds = {
    "98105697395689",
    "115706752305794",
    "72182155407310",
    "95802026624883",
    "96959123077498",
    "72722244508749"
}
getgenv().punchAnimIds = {
    "108911997126897",
    "82137285150006",
    "129843313690921",
    "140703210927645",
    "136007065400978",
    "86096387000557",
    "87259391926321",
    "86709774283672"
}
getgenv().cachedPlayerGui = PlayerGui
getgenv().cachedPunchBtn, cachedBlockBtn, cachedCharges, cachedCooldown = nil, nil, nil, nil
getgenv().detectionRangeSq = detectionRange * detectionRange
getgenv().refreshUIRefs = function()
    cachedPlayerGui = lp:FindFirstChild("PlayerGui") or PlayerGui
    local main = cachedPlayerGui and cachedPlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        cachedPunchBtn = ability and ability:FindFirstChild("Punch")
        cachedBlockBtn = ability and ability:FindFirstChild("Block")
        cachedCharges = cachedPunchBtn and cachedPunchBtn:FindFirstChild("Charges")
        cachedCooldown = cachedBlockBtn and cachedBlockBtn:FindFirstChild("CooldownTime")
    else
        cachedPunchBtn, cachedBlockBtn, cachedCharges, cachedCooldown = nil, nil, nil, nil
    end
end
refreshUIRefs()
if cachedPlayerGui then
    cachedPlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "MainUI" then
            task.delay(0.02, refreshUIRefs)
        end
    end)
end
lp.CharacterAdded:Connect(function()
    task.delay(0.5, refreshUIRefs)
end)
Combat:CreateSection("Guest 1337 --- Auto Block")
Combat:CreateToggle({
    Name = "Auto Block (Accurate 80%)",
    CurrentValue = false,
    Flag = "AutoBlockAudio",
    Callback = function(state)
        autoBlockAudioOn = state
    end,
})
Combat:CreateInput({
Name = "Sense Radius",
PlaceholderText = "18",
RemoveTextAfterFocusLost = false,
Flag = "DetectionRange",
Callback = function(Text)
detectionRange = tonumber(Text) or detectionRange
detectionRangeSq = detectionRange * detectionRange
end
})
getgenv().detectionCircles = {}
getgenv().killerCirclesVisible = false
getgenv().addKillerCircle = function(killer)
    if not killer:FindFirstChild("HumanoidRootPart") then return end
    if detectionCircles[killer] then return end
    local circle = Instance.new("CylinderHandleAdornment")
    circle.Name = "KillerDetectionCircle"
    circle.Adornee = killer.HumanoidRootPart
    circle.Color3 = Color3.fromRGB(255, 0, 0)
    circle.AlwaysOnTop = true
    circle.ZIndex = 0
    circle.Transparency = 0.7
    circle.Radius = detectionRange / 1.5
    circle.Height = 0.1
    circle.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    circle.Parent = killer.HumanoidRootPart
    detectionCircles[killer] = circle
end
getgenv().removeKillerCircle = function(killer)
    if detectionCircles[killer] then
        detectionCircles[killer]:Destroy()
        detectionCircles[killer] = nil
    end
end
getgenv().refreshKillerCircles = function()
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        if killerCirclesVisible then
            addKillerCircle(killer)
        else
            removeKillerCircle(killer)
        end
    end
end
RunService.RenderStepped:Connect(function()
    for killer, circle in pairs(detectionCircles) do
        if circle and circle.Parent then
            circle.Radius = detectionRange / 1.5
        end
    end
end)
KillersFolder.ChildAdded:Connect(function(killer)
    if killerCirclesVisible then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then
                addKillerCircle(killer)
            end
        end)
    end
end)
KillersFolder.ChildRemoved:Connect(function(killer)
    removeKillerCircle(killer)
end)
Combat:CreateToggle({
    Name = "Radius Visual",
    CurrentValue = false,
    Flag = "KillerCircleToggle",
    Callback = function(state)
        killerCirclesVisible = state
        refreshKillerCircles()
    end
})
getgenv().facingCheckEnabled = false
Combat:CreateToggle({
    Name = "Directional Facing Check",
    CurrentValue = false,
    Flag = "FacingCheckToggle",
    Callback = function(Value)
        facingCheckEnabled = Value
    end
})
Combat:CreateDropdown({
Name = "Directional Facing",
Options = {"Loose", "Strict"},
CurrentOption = "Loose",
Flag = "FacingCheckMode",
Callback = function(Option) looseFacing = Option == "Loose" end
})
getgenv().blockAnimIds = {
    "98105697395689",
    "115706752305794",
    "72182155407310",
    "95802026624883",
    "96959123077498",
    "72722244508749"
}
getgenv().punchAnimIds = {
    "108911997126897",
    "82137285150006",
    "129843313690921",
    "140703210927645",
    "136007065400978",
    "86096387000557",
    "87259391926321",
    "86709774283672"
}
Combat:CreateSection("Guest 1337 --- Auto Punch")
Combat:CreateToggle({
Name = "Auto Punch",
CurrentValue = false,
Flag = "AutoPunchToggle",
Callback = function(Value) autoPunchOn = Value end
})
Combat:CreateToggle({
Name = "Auto Fall Punch",
CurrentValue = false,
Flag = "AutoFallPunchToggle",
Callback = function(Value) autoFallPunchOn = Value end
})
getgenv().Players = game:GetService("Players")
getgenv().RunService = game:GetService("RunService")
getgenv().LocalPlayer = Players.LocalPlayer
getgenv().autoDashEnabled = false
getgenv().DASH_SPEED = 100
getgenv().MIN_TARGET_MAXHP = 300
getgenv().IGNORE_SAME_TEAM = false
getgenv().RESUME_DISTANCE = 3
getgenv().isDashing = false
local function getHRP(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart")
end
local function validTarget(player)
    if not player or player == LocalPlayer then return false end
    local char = player.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = getHRP(char)
    if not humanoid or not hrp then return false end
    if humanoid.Health <= 0 then return false end
    if humanoid.MaxHealth < MIN_TARGET_MAXHP then return false end
    if IGNORE_SAME_TEAM and LocalPlayer.Team and player.Team == LocalPlayer.Team then return false end
    local myChar = LocalPlayer.Character
    if not myChar then return false end
    local myHrp = getHRP(myChar)
    if not myHrp then return false end
    if (hrp.Position - myHrp.Position).Magnitude > punchRange then return false end
    return true
end
local function findClosestValidTarget()
    local best, bestDist = nil, math.huge
    local myChar = LocalPlayer.Character
    if not myChar then return nil end
    local myHrp = getHRP(myChar)
    if not myHrp then return nil end
    for _, p in pairs(Players:GetPlayers()) do
        if validTarget(p) then
            local targetHrp = getHRP(p.Character)
            local d = (targetHrp.Position - myHrp.Position).Magnitude
            if d < bestDist then
                bestDist = d
                best = p
            end
        end
    end
    return best
end
local function dashToTarget(player)
    if isDashing then return end
    if not player or not player.Character then return end
    local myChar = LocalPlayer.Character
    if not myChar then return end
    local myHrp = getHRP(myChar)
    local tgtHrp = getHRP(player.Character)
    if not myHrp or not tgtHrp then return end
    isDashing = true
    while autoDashEnabled
      and player
      and player.Character
      and player.Character:FindFirstChildOfClass("Humanoid")
      and player.Character:FindFirstChildOfClass("Humanoid").Health > 0
      and myHrp.Parent
      and tgtHrp.Parent do
        local rootPart = getHRP(myChar)
        local humanoid = myChar:FindFirstChildOfClass("Humanoid")
        local lv = rootPart and rootPart:FindFirstChild("LinearVelocity")
        if not rootPart or not humanoid or not lv then break end
        local dir = (tgtHrp.Position - myHrp.Position)
        local horiz = Vector3.new(dir.X, 0, dir.Z)
        local dist = horiz.Magnitude
        if dist > RESUME_DISTANCE then
            local unit = (horiz.Magnitude > 0) and horiz.Unit or Vector3.new(0,0,0)
            local vel = unit * DASH_SPEED
            local currentY = myHrp.AssemblyLinearVelocity.Y
            myHrp.AssemblyLinearVelocity = Vector3.new(vel.X, currentY, vel.Z)
        else
            local currentY = myHrp.AssemblyLinearVelocity.Y
            myHrp.AssemblyLinearVelocity = Vector3.new(0, currentY, 0)
        end
        RunService.Heartbeat:Wait()
    end
    if myHrp and myHrp.Parent then
        local currentY = myHrp.AssemblyLinearVelocity.Y
        myHrp.AssemblyLinearVelocity = Vector3.new(0, currentY, 0)
    end
    isDashing = false
end
local function isPunchAnimationPlaying()
    local char = LocalPlayer.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    local trackList = humanoid:GetPlayingAnimationTracks()
    for _, track in ipairs(trackList) do
        local animId = tostring(track.Animation.AnimationId)
        if getgenv().slashPunchAnimGuest == true then
            if animId == "rbxassetid://109589533330665" then
                return true
            end
        else
            for _, id in ipairs(punchAnimIds) do
                if animId == "rbxassetid://" .. id then
                    return true
                end
            end
        end
    end
    return false
end
RunService.Heartbeat:Connect(function()
    if not autoDashEnabled then return end
    local char = LocalPlayer.Character
    if not char then return end
    if char.Name ~= "Guest1337" then return end
    if not isPunchAnimationPlaying() then return end
    local rootPart = getHRP(char)
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local lv = rootPart and rootPart:FindFirstChild("LinearVelocity")
    if not rootPart or not humanoid or not lv then return end
    if isDashing then return end
    local target = findClosestValidTarget()
    if target then
        coroutine.wrap(function()
            dashToTarget(target)
        end)()
    end
end)
Combat:CreateToggle({
    Name = "True Punch Dash",
    CurrentValue = false,
    Flag = "PunchDashToggle",
    Callback = function(Value)
        autoDashEnabled = Value
    end
})
getgenv().fireRemoteBlock = function()
    local args = {
        "UseActorAbility",
        { buffer.fromstring("\"Block\"") }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end
getgenv().fireRemotePunch = function()
    local args = {
        "UseActorAbility",
        { buffer.fromstring("\"Punch\"") }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end
getgenv().isFacing = function(localRoot, targetRoot)
    if not facingCheckEnabled then
        return true
    end
    local dir = (localRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return looseFacing and dot > -0.3 or dot > 0
end
getgenv().cachedAnimator = nil
getgenv().refreshAnimator = function()
    local char = lp.Character
    if not char then
        cachedAnimator = nil
        return
    end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        local anim = hum:FindFirstChildOfClass("Animator")
        cachedAnimator = anim or nil
    else
        cachedAnimator = nil
    end
end
lp.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    refreshAnimator()
end)
getgenv().soundHooks = {}
getgenv().soundBlockedUntil = {}
getgenv().getNearestKillerRoot = function(maxDist)
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return nil end
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, closestDist = nil, maxDist or math.huge
    for _, killer in ipairs(killersFolder:GetChildren()) do
        local hrp = killer:FindFirstChild("HumanoidRootPart")
        if hrp then
            local dist = (hrp.Position - myRoot.Position).Magnitude
            if dist < closestDist then
                closest, closestDist = hrp, dist
            end
        end
    end
    return closest
end
getgenv().extractNumericSoundId = function(sound)
    if not sound or not sound.SoundId then return nil end
    local sid = tostring(sound.SoundId)
    local num = sid:match("%d+")
    if num then return num end
    local hash = sid:match("[&%?]hash=([^&]+)")
    if hash then return "&hash="..hash end
    local path = sid:match("rbxasset://sounds/.+")
    if path then return path end
    return nil
end
getgenv().getSoundWorldPosition = function(sound)
    if not sound then return nil end
    if sound.Parent and sound.Parent:IsA("BasePart") then
        return sound.Parent.Position, sound.Parent
    end
    if sound.Parent and sound.Parent:IsA("Attachment") and sound.Parent.Parent and sound.Parent.Parent:IsA("BasePart") then
        return sound.Parent.Parent.Position, sound.Parent.Parent
    end
    local found = sound.Parent and sound.Parent:FindFirstChildWhichIsA("BasePart", true)
    if found then
        return found.Position, found
    end
    return nil, nil
end
getgenv().getCharacterFromDescendant = function(inst)
    if not inst then return nil end
    local model = inst:FindFirstAncestorOfClass("Model")
    if model and model:FindFirstChildOfClass("Humanoid") then
        return model
    end
    return nil
end
getgenv().attemptBlockForSound = function(sound)
    if not autoBlockAudioOn then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end
    local id = extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end
    local t = tick()
    if soundBlockedUntil[sound] and t < soundBlockedUntil[sound] then return end
    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local soundPos, soundPart = getSoundWorldPosition(sound)
    if not soundPos or not soundPart then return end
    local char = getCharacterFromDescendant(soundPart)
    local plr = char and Players:GetPlayerFromCharacter(char)
    if not plr or plr == lp then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local dvec = hrp.Position - myRoot.Position
    local distSq = dvec.X * dvec.X + dvec.Y * dvec.Y + dvec.Z * dvec.Z
    if distSq > detectionRangeSq then
        return
    end
    if cachedCooldown and cachedCooldown.Text ~= "" then
        return
    end
    if facingCheckEnabled and not isFacing(myRoot, hrp) then
        return
    end
    getgenv().fireRemoteBlock()
    if doubleblocktech and cachedCharges and cachedCharges.Text == "1" then
        getgenv().fireRemotePunch()
    end
    soundBlockedUntil[sound] = t + 1.2
end
getgenv().hookSound = function(sound)
    if not sound or not sound:IsA("Sound") then return end
    if soundHooks[sound] then return end
    local playedConn = sound.Played:Connect(function()
        pcall(attemptBlockForSound, sound)
    end)
    local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
        if sound.IsPlaying then
            pcall(attemptBlockForSound, sound)
        end
    end)
    local destroyConn
    destroyConn = sound.Destroying:Connect(function()
        if playedConn and playedConn.Connected then playedConn:Disconnect() end
        if propConn and propConn.Connected then propConn:Disconnect() end
        if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
        soundHooks[sound] = nil
        soundBlockedUntil[sound] = nil
    end)
    soundHooks[sound] = {playedConn, propConn, destroyConn}
    if sound.IsPlaying then
        task.spawn(function() pcall(attemptBlockForSound, sound) end)
    end
end
for _, desc in ipairs(game:GetDescendants()) do
    if desc:IsA("Sound") then
        pcall(hookSound, desc)
    end
end
game.DescendantAdded:Connect(function(desc)
    if desc:IsA("Sound") then
        pcall(hookSound, desc)
    end
end)
local lp = getgenv().lp or Players.LocalPlayer
RunService.RenderStepped:Connect(function()
local myChar = getgenv().lp.Character
local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
local gui = PlayerGui:FindFirstChild("MainUI")
local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
local charges = punchBtn and punchBtn:FindFirstChild("Charges")
local blockBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Block")
local cooldown = blockBtn and blockBtn:FindFirstChild("CooldownTime")
if autoPunchOn and punchBtn and charges then
	local chargeCount = tonumber(charges.Text) or 0
	if chargeCount >= 1 then
		local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
		if killersFolder and myRoot then
			for _, name in ipairs(getgenv().killerNames) do
				local killer = killersFolder:FindFirstChild(name)
				if killer and killer:FindFirstChild("HumanoidRootPart") then
					local root = killer.HumanoidRootPart
					if (root.Position - myRoot.Position).Magnitude <= getgenv().punchRange then
						for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click or {})) do
							pcall(function() getgenv().fireRemotePunch() end)
						end
						break
					end
				end
			end
		end
	end
end
	if autoFallPunchOn and punchBtn and charges then
		local chargeCount = tonumber(charges.Text) or 0
		if chargeCount >= 1 then
			local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
			if killersFolder and myRoot then
				for _, name in ipairs(getgenv().killerNames) do
					local killer = killersFolder:FindFirstChild(name)
					if killer and killer:FindFirstChild("HumanoidRootPart") then
						local root = killer.HumanoidRootPart
						if (root.Position - myRoot.Position).Magnitude <= getgenv().punchRange then
							myRoot.CFrame = myRoot.CFrame + Vector3.new(0, 8, 0)
							for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click or {})) do
								pcall(function() conn:Fire() end)
							end
							task.wait(0.01)
						end
					end
				end
			end
		end
	end
end)
getgenv().punchRange = 50
getgenv().punchRangeSq = getgenv().punchRange * getgenv().punchRange
getgenv().punchRangeVisible = false
getgenv().punchRangeAdornment = nil
local function createPunchRangeAdornment()
    local lpChar = lp.Character
    if not lpChar then return end
    local hrp = lpChar:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    if punchRangeAdornment and punchRangeAdornment.Parent then return end
    local adv = Instance.new("CylinderHandleAdornment")
    adv.Name = "AutoPunchRangeCircle"
    adv.Adornee = hrp
    adv.Radius = punchRange / 1.5
    adv.Height = 0.1
    adv.Transparency = 0.6
    adv.AlwaysOnTop = true
    adv.ZIndex = 0
    adv.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    adv.Parent = hrp
    getgenv().punchRangeAdornment = adv
end
local function removePunchRangeAdornment()
    if punchRangeAdornment then
        pcall(function() punchRangeAdornment:Destroy() end)
        getgenv().punchRangeAdornment = nil
    end
end
RunService.RenderStepped:Connect(function()
    if punchRangeAdornment and punchRangeAdornment.Parent then
        punchRangeAdornment.Radius = punchRange / 1.5
    end
end)
lp.CharacterAdded:Connect(function(char)
    task.wait(0.3)
    if punchRangeVisible then
        pcall(createPunchRangeAdornment)
    end
end)
Combat:CreateToggle({
    Name = "Punch Range Visual",
    CurrentValue = false,
    Flag = "PunchRangeToggle",
    Callback = function(state)
        punchRangeVisible = state
        if punchRangeVisible then
            pcall(createPunchRangeAdornment)
        else
            pcall(removePunchRangeAdornment)
        end
    end,
})
Combat:CreateInput({
    Name = "Punch Radius",
    PlaceholderText = tostring(punchRange),
    RemoveTextAfterFocusLost = false,
    Flag = "PunchRangeInput",
    Callback = function(Text)
        local v = tonumber(Text)
        if v and v > 0 then
            punchRange = v
            punchRangeSq = punchRange * punchRange
            if punchRangeAdornment and punchRangeAdornment.Parent then
                punchRangeAdornment.Radius = punchRange / 1.5
            end
        end
    end
})
getgenv().RunService = game:GetService("RunService")
getgenv().Players = game:GetService("Players")
getgenv().LocalPlayer = Players.LocalPlayer
getgenv().KillersContainer = workspace:WaitForChild("Players"):WaitForChild("Killers")
getgenv().HDT_Enabled = false
getgenv().HDT_InProgress = false
getgenv().HDT_Speed = 5.6
getgenv().HDT_StartDelay = 0
getgenv().BlockedAnimationIds = {
    "98105697395689",
    "115706752305794",
    "72182155407310",
    "95802026624883",
    "96959123077498",
    "72722244508749"
}
getgenv().CachedAnimator = nil
getgenv().UpdateAnimatorCache = function()
    local character = LocalPlayer.Character
    if not character then
        CachedAnimator = nil
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        CachedAnimator = humanoid:FindFirstChildOfClass("Animator")
    else
        CachedAnimator = nil
    end
end
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    UpdateAnimatorCache()
end)
getgenv().GetKillerRootPart = function(killer)
    if not killer then return nil end
    return killer:FindFirstChild("HumanoidRootPart")
        or killer.PrimaryPart
        or killer:FindFirstChildWhichIsA("BasePart", true)
end
getgenv().FindClosestKiller = function()
    local character = LocalPlayer.Character
    local myRoot = character and character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local nearestKiller, shortestDistance = nil, math.huge
    for _, killer in ipairs(KillersContainer:GetChildren()) do
        if killer:IsA("Model") then
            local killerRoot = killer:FindFirstChild("HumanoidRootPart")
            if killerRoot then
                local distance = (killerRoot.Position - myRoot.Position).Magnitude
                if distance < shortestDistance then
                    nearestKiller, shortestDistance = killer, distance
                end
            end
        end
    end
    return nearestKiller
end
getgenv().StartDragKiller = function(killerModel)
    if HDT_InProgress or not killerModel or not killerModel.Parent then return end
    local character = LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local targetRoot = GetKillerRootPart(killerModel)
    if not (hrp and humanoid and targetRoot) then return end
    HDT_InProgress = true
    local originalWalk = humanoid.WalkSpeed
    local originalJump = humanoid.JumpPower
    local originalPlatformStand = humanoid.PlatformStand
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    humanoid.PlatformStand = false
    local bodyVel = Instance.new("BodyVelocity")
    bodyVel.MaxForce = Vector3.new(1e5, 0, 1e5)
    bodyVel.Velocity = Vector3.zero
    bodyVel.Parent = hrp
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not HDT_InProgress then
            connection:Disconnect()
            if bodyVel and bodyVel.Parent then pcall(function() bodyVel:Destroy() end) end
            humanoid.WalkSpeed = originalWalk
            humanoid.JumpPower = originalJump
            humanoid.PlatformStand = originalPlatformStand
            return
        end
        if not (character and character.Parent and killerModel and killerModel.Parent) then
            HDT_InProgress = false
            return
        end
        targetRoot = GetKillerRootPart(killerModel)
        if not targetRoot then
            HDT_InProgress = false
            return
        end
        local offset = targetRoot.Position - hrp.Position
        local distance = offset.Magnitude
        local horizontal = Vector3.new(offset.X, 0, offset.Z)
        if horizontal.Magnitude > 0.01 then
            local direction = horizontal.Unit
            bodyVel.Velocity = Vector3.new(direction.X * HDT_Speed, 0, direction.Z * HDT_Speed)
        else
            bodyVel.Velocity = Vector3.zero
        end
        if distance <= 2.0 then
            HDT_InProgress = false
        end
    end)
    task.delay(0.4, function()
        if HDT_InProgress then
            HDT_InProgress = false
        end
    end)
end
RunService.RenderStepped:Connect(function()
    if not HDT_Enabled then return end
    if not CachedAnimator then UpdateAnimatorCache() end
    local animator = CachedAnimator
    if not animator then return end
    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
        local ok, animId = pcall(function()
            return track.Animation and tostring(track.Animation.AnimationId):match("%d+")
        end)
        if ok and animId and table.find(BlockedAnimationIds, animId) then
            local pos = track.TimePosition or 0
            if pos <= 0.12 then
                local nearest = FindClosestKiller()
                if nearest then
                    task.wait(HDT_StartDelay)
                    task.spawn(function()
                        StartDragKiller(nearest)
                    end)
                end
            end
        end
    end
end)
getgenv().AntiFlick_Enabled = false
task.spawn(function()
    while true do
        RunService.Heartbeat:Wait()
        if not (HDT_Enabled and AntiFlick_Enabled) then
            task.wait(0.15)
            continue
        end
        local character = LocalPlayer.Character
        local myRoot = character and character:FindFirstChild("HumanoidRootPart")
        if not myRoot then task.wait(0.15) continue end
        local nearbyZone = nil
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and part.Name == "AntiFlickZone" then
                if (part.Position - myRoot.Position).Magnitude <= detectionRange then
                    nearbyZone = part
                    break
                end
            end
        end
        if nearbyZone and not HDT_InProgress then
            local nearest = FindClosestKiller()
            if nearest then
                task.wait(HDT_StartDelay)
                task.spawn(function()
                    StartDragKiller(nearest)
                end)
            end
        end
        task.wait(0.12)
    end
end)
Combat:CreateSection("Guest 1337 --- Tech")
Combat:CreateToggle({
    Name = "Hitbox Dragging Tech",
    CurrentValue = false,
    Flag = "HDT_Toggle",
    Callback = function(state)
        HDT_Enabled = state
    end,
})
Combat:CreateInput({
    Name = "Hitbox Dragging Tech Speed",
    PlaceholderText = "5.6",
    RemoveTextAfterFocusLost = false,
    Flag = "HDT_SpeedInput",
    Callback = function(text)
        HDT_Speed = tonumber(text) or HDT_Speed
    end
})
Combat:CreateInput({
    Name = "Hitbox Dragging Tech Delay",
    PlaceholderText = "0",
    RemoveTextAfterFocusLost = false,
    Flag = "HDT_DelayInput",
    Callback = function(text)
        HDT_StartDelay = tonumber(text) or HDT_StartDelay
    end
})
Combat:CreateToggle({
    Name = "Double Punch Tech",
    CurrentValue = false,
    Flag = "doubleblockTechtoggle",
    Callback = function(state)
        doubleblocktech = state
    end,
})
getgenv().Players = game:GetService("Players")
getgenv().UserInputService = game:GetService("UserInputService")
getgenv().TweenService = game:GetService("TweenService")
getgenv().GenUI_Player = Players.LocalPlayer
getgenv().GenUI_PlayerGui = GenUI_Player:WaitForChild("PlayerGui")
getgenv().screenSize = workspace.CurrentCamera.ViewportSize
getgenv().screenWidth = screenSize.X
getgenv().screenHeight = screenSize.Y
getgenv().frameWidth = math.floor(screenWidth * 0.25)
getgenv().frameHeight = math.floor(screenHeight * 0.4)
getgenv().buttonHeight = math.floor(frameHeight * 0.18)
getgenv().buttonSpacing = math.floor(frameHeight * 0.02)
getgenv().GenUI_AddTextOutline = function(obj)
	if not (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) then return end
	local outlineFolder = Instance.new("Folder")
	outlineFolder.Name = "GenUI_TextOutline"
	outlineFolder.Parent = obj
	local offsets = {
		Vector2.new(-1, 0), Vector2.new(1, 0),
		Vector2.new(0, -1), Vector2.new(0, 1),
		Vector2.new(-1, -1), Vector2.new(1, 1),
		Vector2.new(-1, 1), Vector2.new(1, -1)
	}
	for _, offset in ipairs(offsets) do
		local shadow = Instance.new("TextLabel")
		shadow.BackgroundTransparency = 1
		shadow.Size = obj.Size
		shadow.Position = UDim2.fromOffset(offset.X, offset.Y)
		shadow.AnchorPoint = obj.AnchorPoint
		shadow.ZIndex = obj.ZIndex - 1
		shadow.Text = obj.Text
		shadow.Font = obj.Font
		shadow.TextSize = obj.TextSize
		shadow.TextColor3 = Color3.fromRGB(0, 0, 0)
		shadow.TextXAlignment = obj.TextXAlignment
		shadow.TextYAlignment = obj.TextYAlignment
		shadow.Parent = outlineFolder
	end
	obj.TextColor3 = Color3.fromRGB(255, 255, 255)
	obj:GetPropertyChangedSignal("Text"):Connect(function()
		for _, shadow in ipairs(outlineFolder:GetChildren()) do
			shadow.Text = obj.Text
		end
	end)
end
getgenv().GenUI_ScreenGui = Instance.new("ScreenGui")
GenUI_ScreenGui.Name = "GenUI_Screen"
GenUI_ScreenGui.ResetOnSpawn = false
GenUI_ScreenGui.DisplayOrder = 999999
GenUI_ScreenGui.Parent = GenUI_PlayerGui
GenUI_ScreenGui.Enabled = false
getgenv().GenUI_Frame = Instance.new("Frame")
GenUI_Frame.Name = "GenUI_MainFrame"
GenUI_Frame.Size = UDim2.new(0, frameWidth, 0, frameHeight)
GenUI_Frame.Position = UDim2.new(0.5, -frameWidth / 2, 0.5, -frameHeight / 2)
GenUI_Frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
GenUI_Frame.BorderSizePixel = 0
GenUI_Frame.Active = true
GenUI_Frame.Draggable = true
GenUI_Frame.Parent = GenUI_ScreenGui
Instance.new("UICorner", GenUI_Frame).CornerRadius = UDim.new(0, 12)
Instance.new("UIStroke", GenUI_Frame).Thickness = 2
GenUI_Frame.UIStroke.Color = Color3.fromRGB(0, 0, 0)
GenUI_Frame.UIStroke.Transparency = 0.3
local buttonContainer = Instance.new("Frame")
buttonContainer.Name = "ButtonContainer"
buttonContainer.Size = UDim2.new(1, 0, 1, 0)
buttonContainer.BackgroundTransparency = 1
buttonContainer.Parent = GenUI_Frame
local layout = Instance.new("UIListLayout")
layout.Parent = buttonContainer
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
layout.VerticalAlignment = Enum.VerticalAlignment.Center
layout.Padding = UDim.new(0, buttonSpacing)
local function CreateButton(name, text, color, hoverColor, orderIndex, animId)
	local btn = Instance.new("TextButton")
	btn.Name = name
	btn.Size = UDim2.new(0, frameWidth - 20, 0, buttonHeight)
	btn.BackgroundColor3 = color
	btn.BorderSizePixel = 0
	btn.Text = text
	btn.TextSize = 15
	btn.Font = Enum.Font.GothamBold
	btn.TextXAlignment = Enum.TextXAlignment.Center
	btn.TextYAlignment = Enum.TextYAlignment.Center
	btn.LayoutOrder = orderIndex
	btn.Parent = buttonContainer
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
	Instance.new("UIStroke", btn).Thickness = 1.5
	btn.UIStroke.Color = Color3.fromRGB(0, 0, 0)
	btn.UIStroke.Transparency = 0.3
	GenUI_AddTextOutline(btn)
	btn.MouseEnter:Connect(function()
		btn.BackgroundColor3 = hoverColor
	end)
	btn.MouseLeave:Connect(function()
		btn.BackgroundColor3 = color
	end)
	btn.MouseButton1Click:Connect(function()
		pcall(function()
			local lp = Players.LocalPlayer
			local char = lp.Character or lp.CharacterAdded:Wait()
			local humanoid = char and char:FindFirstChildOfClass("Humanoid")
			if not humanoid then return end
			local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
			for _, t in ipairs(animator:GetPlayingAnimationTracks()) do
				local id = tostring(t.Animation and t.Animation.AnimationId or ""):match("%d+")
				if id == tostring(animId):match("%d+") then
					pcall(function() t:Stop() end)
				end
			end
			local anim = Instance.new("Animation")
			anim.AnimationId = animId
			local track = animator:LoadAnimation(anim)
			track:Play()
		end)
	end)
	return btn
end
local GenUI_Button1 = CreateButton("FakeLag", "Fake Lag Tech (Run)", Color3.fromRGB(0, 170, 0), Color3.fromRGB(0, 200, 0), 1, "rbxassetid://136252471123500")
local GenUI_Button2 = CreateButton("WalkAnim", "Fake Lag Tech (Walk)", Color3.fromRGB(0, 120, 200), Color3.fromRGB(0, 150, 255), 2, "rbxassetid://108018357044094")
local GenUI_Button3 = CreateButton("InjuredRun", "Fake Lag Tech (Injured Run)", Color3.fromRGB(200, 50, 50), Color3.fromRGB(255, 80, 80), 3, "rbxassetid://115946474977409")
local GenUI_Button4 = CreateButton("InjuredWalk", "Fake Lag Tech (Injured Walk)", Color3.fromRGB(255, 170, 0), Color3.fromRGB(255, 200, 50), 4, "rbxassetid://132377038617766")
Combat:CreateToggle({
	Name = "Fake Lag Tech",
	CurrentValue = false,
	Flag = "FakeLagTech",
	Callback = function(value)
		GenUI_ScreenGui.Enabled = value
	end,
})
getgenv().SVC_REP = game:GetService("ReplicatedStorage")
getgenv().SVC_TWEEN = game:GetService("TweenService")
getgenv().SVC_RUN = game:GetService("RunService")
getgenv().SVC_PLAY = game:GetService("Players")
getgenv().LP = getgenv().SVC_PLAY.LocalPlayer
getgenv().GUI_MAIN = getgenv().LP:WaitForChild("PlayerGui")
getgenv().CHAR_HUM, getgenv().CHAR_ANIM = nil, nil
getgenv().AUTO_CHARGE_TRIGGER_SOUNDS = {
    ["102228729296384"] = true,
    ["140242176732868"] = true,
    ["112809109188560"] = true,
    ["136323728355613"] = true,
    ["115026634746636"] = true,
    ["84116622032112"] = true,
    ["108907358619313"] = true,
    ["127793641088496"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["119942598489800"] = true,
    ["84307400688050"] = true,
    ["113037804008732"] = true,
    ["105200830849301"] = true,
    ["75330693422988"] = true,
    ["82221759983649"] = true,
    ["81702359653578"] = true,
    ["108610718831698"] = true,
    ["112395455254818"] = true,
    ["136323728355613"] = true,
    ["81702359653578"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["109431876587852"] = true,
    ["115026634746636"] = true,
    ["119942598489800"] = true,
    ["109348678063422"] = true,
    ["85853080745515"] = true
}
getgenv().LAST_AIM_TRIGGER = {}
getgenv().AIM_WINDOW = 0.5
getgenv().AIM_COOLDOWN = 0.6
getgenv().AUTO_CHARGE_AUDIO = false
getgenv().LOOSE_FACING = false
getgenv().SENSE_RADIUS = 18
getgenv().MIN_CHARGE_DISTANCE = 10
getgenv().MIN_CHARGE_DISTANCE_SQ = getgenv().MIN_CHARGE_DISTANCE * getgenv().MIN_CHARGE_DISTANCE
getgenv().KILLER_NAME_LIST = {"c00lkidd", "Jason", "JohnDoe", "1x1x1x1", "Noli", "Slasher"}
getgenv().KILLERS_FOLDER = workspace:WaitForChild("Players"):WaitForChild("Killers")
getgenv().CACHED_PGUI = GUI_MAIN
getgenv().CACHED_PUNCH_BTN = nil
getgenv().CACHED_CHARGE_BTN = nil
getgenv().CACHED_CHARGES = nil
getgenv().CACHED_COOLDOWN = nil
getgenv().SENSE_RADIUS_SQ = getgenv().SENSE_RADIUS * getgenv().SENSE_RADIUS
getgenv().REFRESH_UI_REFS = function()
    getgenv().CACHED_PGUI = getgenv().LP:FindFirstChild("PlayerGui") or GUI_MAIN
    local mainui = getgenv().CACHED_PGUI and getgenv().CACHED_PGUI:FindFirstChild("MainUI")
    if mainui then
        local ability = mainui:FindFirstChild("AbilityContainer")
        getgenv().CACHED_PUNCH_BTN = ability and ability:FindFirstChild("Punch")
        getgenv().CACHED_CHARGE_BTN = ability and ability:FindFirstChild("Charge")
        getgenv().CACHED_CHARGES = getgenv().CACHED_PUNCH_BTN and getgenv().CACHED_PUNCH_BTN:FindFirstChild("Charges")
        getgenv().CACHED_COOLDOWN = getgenv().CACHED_CHARGE_BTN and getgenv().CACHED_CHARGE_BTN:FindFirstChild("CooldownTime")
    else
        getgenv().CACHED_CHARGE_BTN, getgenv().CACHED_CHARGES, getgenv().CACHED_COOLDOWN = nil, nil, nil
    end
end
getgenv().REFRESH_UI_REFS()
if getgenv().CACHED_PGUI then
    getgenv().CACHED_PGUI.ChildAdded:Connect(function(child)
        if child.Name == "MainUI" then
            task.delay(0.02, getgenv().REFRESH_UI_REFS)
        end
    end)
end
getgenv().LP.CharacterAdded:Connect(function()
    task.delay(0.5, getgenv().REFRESH_UI_REFS)
end)
Combat:CreateSection("Guest 1337 --- Auto Charge")
Combat:CreateToggle({
    Name = "Auto Block Charge (Accurate 80%)",
    CurrentValue = false,
    Flag = "AutoChargeAudio",
    Callback = function(state)
        getgenv().AUTO_CHARGE_AUDIO = state
    end,
})
getgenv().MIN_CHARGE_DISTANCE = getgenv().MIN_CHARGE_DISTANCE or 10
getgenv().MIN_CHARGE_DISTANCE_SQ = getgenv().MIN_CHARGE_DISTANCE * getgenv().MIN_CHARGE_DISTANCE
getgenv().DETECTION_CIRCLES = {}
getgenv().KILLER_CIRCLES_VISIBLE = false
local function make_circle_adorn(name, adornee, radius, color3, transparency, alwaysOnTop)
    local adorn = Instance.new("CylinderHandleAdornment")
    adorn.Name = name
    adorn.Adornee = adornee
    adorn.Color3 = color3 or Color3.fromRGB(255,0,0)
    adorn.AlwaysOnTop = alwaysOnTop == nil and true or alwaysOnTop
    adorn.ZIndex = 0
    adorn.Transparency = transparency or 0.7
    adorn.Radius = radius or 1
    adorn.Height = 0.1
    adorn.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    adorn.Parent = adornee
    return adorn
end
getgenv().ADD_KILLER_CIRCLE = function(killer)
    if not killer:FindFirstChild("HumanoidRootPart") then return end
    if getgenv().DETECTION_CIRCLES[killer] then return end
    local hrp = killer.HumanoidRootPart
    local outerRadius = getgenv().SENSE_RADIUS / 1.5
    local outer = make_circle_adorn("KillerDetectionCircle_Outer", hrp, outerRadius, Color3.fromRGB(255,0,0), 0.7, true)
    local inner = nil
    if getgenv().MIN_CHARGE_DISTANCE and getgenv().MIN_CHARGE_DISTANCE >= 0 then
        local innerRadius = getgenv().MIN_CHARGE_DISTANCE / 1.5
        inner = make_circle_adorn("KillerDetectionCircle_Inner", hrp, innerRadius, Color3.fromRGB(255,200,0), 0.6, true)
    end
    getgenv().DETECTION_CIRCLES[killer] = { outer = outer, inner = inner }
end
getgenv().REMOVE_KILLER_CIRCLE = function(killer)
    local entry = getgenv().DETECTION_CIRCLES[killer]
    if entry then
        if entry.outer and entry.outer.Parent then entry.outer:Destroy() end
        if entry.inner and entry.inner.Parent then entry.inner:Destroy() end
        getgenv().DETECTION_CIRCLES[killer] = nil
    end
end
getgenv().REFRESH_KILLER_CIRCLES = function()
    for _, k in ipairs(getgenv().KILLERS_FOLDER:GetChildren()) do
        if getgenv().KILLER_CIRCLES_VISIBLE then
            if not getgenv().DETECTION_CIRCLES[k] then
                getgenv().ADD_KILLER_CIRCLE(k)
            else
                local entry = getgenv().DETECTION_CIRCLES[k]
                if entry.outer and entry.outer.Parent then
                    entry.outer.Radius = getgenv().SENSE_RADIUS / 1.5
                end
                if getgenv().MIN_CHARGE_DISTANCE and getgenv().MIN_CHARGE_DISTANCE >= 10 then
                    if not entry.inner or not entry.inner.Parent then
                        local hrp = k:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            entry.inner = make_circle_adorn("KillerDetectionCircle_Inner", hrp, getgenv().MIN_CHARGE_DISTANCE / 1.5, Color3.fromRGB(255,200,0), 0.6, true)
                        end
                    else
                        entry.inner.Radius = getgenv().MIN_CHARGE_DISTANCE / 1.5
                    end
                else
                    if entry.inner and entry.inner.Parent then
                        entry.inner:Destroy()
                        entry.inner = nil
                    end
                end
            end
        else
            getgenv().REMOVE_KILLER_CIRCLE(k)
        end
    end
end
getgenv().SVC_RUN.RenderStepped:Connect(function()
    for k, entry in pairs(getgenv().DETECTION_CIRCLES) do
        if entry and entry.outer and entry.outer.Parent then
            entry.outer.Radius = getgenv().SENSE_RADIUS / 1.5
        end
        if entry and entry.inner and entry.inner.Parent then
            entry.inner.Radius = (getgenv().MIN_CHARGE_DISTANCE or 0) / 1.5
        end
    end
end)
getgenv().KILLERS_FOLDER.ChildAdded:Connect(function(killer)
    if getgenv().KILLER_CIRCLES_VISIBLE then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then getgenv().ADD_KILLER_CIRCLE(killer) end
        end)
    end
end)
getgenv().KILLERS_FOLDER.ChildRemoved:Connect(function(killer)
    getgenv().REMOVE_KILLER_CIRCLE(killer)
end)
Combat:CreateToggle({
    Name = "Radius Visual",
    CurrentValue = false,
    Flag = "KillerCircleToggle",
    Callback = function(state)
        getgenv().KILLER_CIRCLES_VISIBLE = state
        getgenv().REFRESH_KILLER_CIRCLES()
    end
})
Combat:CreateInput({
    Name = "Sense Radius",
    PlaceholderText = "18",
    RemoveTextAfterFocusLost = false,
    Flag = "DetectionRange",
    Callback = function(Text)
        getgenv().SENSE_RADIUS = tonumber(Text) or getgenv().SENSE_RADIUS
        getgenv().SENSE_RADIUS_SQ = getgenv().SENSE_RADIUS * getgenv().SENSE_RADIUS
        getgenv().MIN_CHARGE_DISTANCE_SQ = getgenv().MIN_CHARGE_DISTANCE * getgenv().MIN_CHARGE_DISTANCE
    end
})
Combat:CreateInput({
    Name = "Min Sense Radius",
    PlaceholderText = tostring(getgenv().MIN_CHARGE_DISTANCE),
    RemoveTextAfterFocusLost = false,
    Flag = "MinChargeDistance",
    Callback = function(Text)
        local val = tonumber(Text)
        if val and val >= 0 then
            getgenv().MIN_CHARGE_DISTANCE = val
            getgenv().MIN_CHARGE_DISTANCE_SQ = val * val
            if getgenv().KILLER_CIRCLES_VISIBLE then
                getgenv().REFRESH_KILLER_CIRCLES()
            end
        end
    end
})
getgenv().KILLERS_FOLDER.ChildAdded:Connect(function(killer)
    if getgenv().KILLER_CIRCLES_VISIBLE then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then getgenv().ADD_KILLER_CIRCLE(killer) end
        end)
    end
end)
getgenv().KILLERS_FOLDER.ChildRemoved:Connect(function(killer)
    getgenv().REMOVE_KILLER_CIRCLE(killer)
end)
getgenv().FACING_CHECK_ENABLED = false
Combat:CreateToggle({
    Name = "Directional Facing Check",
    CurrentValue = false,
    Flag = "FacingCheckToggle",
    Callback = function(Value)
        getgenv().FACING_CHECK_ENABLED = Value
    end
})
Combat:CreateDropdown({
    Name = "Directional Facing",
    Options = {"Loose", "Strict"},
    CurrentOption = "Loose",
    Flag = "FacingCheckMode",
    Callback = function(Option) getgenv().LOOSE_FACING = Option == "Loose" end
})
getgenv().FIRE_REMOTE_CHARGE = function()
    local args = {
        "UseActorAbility",
        { buffer.fromstring("\"Charge\"") }
    }
    getgenv().SVC_REP:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end
getgenv().IS_FACING = function(localRoot, targetRoot)
    if not getgenv().FACING_CHECK_ENABLED then return true end
    local dir = (localRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return getgenv().LOOSE_FACING and dot > -0.3 or dot > 0
end
getgenv().CACHED_ANIMATOR = nil
getgenv().REFRESH_ANIMATOR = function()
    local char = getgenv().LP.Character
    if not char then
        getgenv().CACHED_ANIMATOR = nil
        return
    end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        local anim = hum:FindFirstChildOfClass("Animator")
        getgenv().CACHED_ANIMATOR = anim or nil
    else
        getgenv().CACHED_ANIMATOR = nil
    end
end
getgenv().LP.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    getgenv().REFRESH_ANIMATOR()
end)
getgenv().SOUND_HOOKS = {}
getgenv().SOUND_BLOCKED_UNTIL = {}
getgenv().GET_NEAREST_KILLER_ROOT = function(maxDist)
    local kfolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not kfolder then return nil end
    local myroot = getgenv().LP.Character and getgenv().LP.Character:FindFirstChild("HumanoidRootPart")
    if not myroot then return nil end
    local closest, closestDist = nil, maxDist or math.huge
    for _, kk in ipairs(kfolder:GetChildren()) do
        local hrp = kk:FindFirstChild("HumanoidRootPart")
        if hrp then
            local d = (hrp.Position - myroot.Position).Magnitude
            if d < closestDist then closest, closestDist = hrp, d end
        end
    end
    return closest
end
getgenv().EXTRACT_NUMERIC_SOUND_ID = function(sound)
    if not sound or not sound.SoundId then return nil end
    local sid = tostring(sound.SoundId)
    local num = sid:match("%d+")
    if num then return num end
    local hash = sid:match("[&%?]hash=([^&]+)")
    if hash then return "&hash="..hash end
    local path = sid:match("rbxasset://sounds/.+")
    if path then return path end
    return nil
end
getgenv().GET_SOUND_WORLD_POSITION = function(sound)
    if not sound then return nil end
    if sound.Parent and sound.Parent:IsA("BasePart") then
        return sound.Parent.Position, sound.Parent
    end
    if sound.Parent and sound.Parent:IsA("Attachment") and sound.Parent.Parent and sound.Parent.Parent:IsA("BasePart") then
        return sound.Parent.Parent.Position, sound.Parent.Parent
    end
    local found = sound.Parent and sound.Parent:FindFirstChildWhichIsA("BasePart", true)
    if found then return found.Position, found end
    return nil, nil
end
getgenv().GET_CHARACTER_FROM_DESCENDANT = function(inst)
    if not inst then return nil end
    local model = inst:FindFirstAncestorOfClass("Model")
    if model and model:FindFirstChildOfClass("Humanoid") then return model end
    return nil
end
getgenv().ATTEMPT_CHARGE_FOR_SOUND = function(sound)
    if not getgenv().AUTO_CHARGE_AUDIO then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end
    local id = getgenv().EXTRACT_NUMERIC_SOUND_ID(sound)
    if not id or not getgenv().AUTO_CHARGE_TRIGGER_SOUNDS[id] then return end
    local t = tick()
    if getgenv().SOUND_BLOCKED_UNTIL[sound] and t < getgenv().SOUND_BLOCKED_UNTIL[sound] then return end
    local myChar = getgenv().LP.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local soundPos, soundPart = getgenv().GET_SOUND_WORLD_POSITION(sound)
    if not soundPos or not soundPart then return end
    local char = getgenv().GET_CHARACTER_FROM_DESCENDANT(soundPart)
    local plr = char and getgenv().SVC_PLAY:GetPlayerFromCharacter(char)
    if not plr or plr == getgenv().LP then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local dvec = hrp.Position - myRoot.Position
    local distSq = dvec.X * dvec.X + dvec.Y * dvec.Y + dvec.Z * dvec.Z
    if distSq < getgenv().MIN_CHARGE_DISTANCE_SQ then
        return
    end
    if distSq > getgenv().SENSE_RADIUS_SQ then return end
    if getgenv().CACHED_COOLDOWN and getgenv().CACHED_COOLDOWN.Text ~= "" then return end
    if getgenv().FACING_CHECK_ENABLED and not getgenv().IS_FACING(myRoot, hrp) then return end
    getgenv().FIRE_REMOTE_CHARGE()
    getgenv().SOUND_BLOCKED_UNTIL[sound] = t + 1.2
end
getgenv().HOOK_SOUND = function(sound)
    if not sound or not sound:IsA("Sound") then return end
    if getgenv().SOUND_HOOKS[sound] then return end
    local playedConn = sound.Played:Connect(function()
        pcall(getgenv().ATTEMPT_CHARGE_FOR_SOUND, sound)
    end)
    local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
        if sound.IsPlaying then pcall(getgenv().ATTEMPT_CHARGE_FOR_SOUND, sound) end
    end)
    local destroyConn
    destroyConn = sound.Destroying:Connect(function()
        if playedConn and playedConn.Connected then playedConn:Disconnect() end
        if propConn and propConn.Connected then propConn:Disconnect() end
        if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
        getgenv().SOUND_HOOKS[sound] = nil
        getgenv().SOUND_BLOCKED_UNTIL[sound] = nil
    end)
    getgenv().SOUND_HOOKS[sound] = {playedConn, propConn, destroyConn}
    if sound.IsPlaying then
        task.spawn(function() pcall(getgenv().ATTEMPT_CHARGE_FOR_SOUND, sound) end)
    end
end
for _, desc in ipairs(game:GetDescendants()) do
    if desc:IsA("Sound") then
        pcall(getgenv().HOOK_SOUND, desc)
    end
end
game.DescendantAdded:Connect(function(desc)
    if desc:IsA("Sound") then
        pcall(getgenv().HOOK_SOUND, desc)
    end
end)
getgenv().RS = game:GetService("ReplicatedStorage")
getgenv().TS = game:GetService("TweenService")
getgenv().RSvc = game:GetService("RunService")
getgenv().Plrs = game:GetService("Players")
getgenv().LocalP = Plrs.LocalPlayer
getgenv().LocalGui = LocalP:WaitForChild("PlayerGui")
getgenv().LocalHum, getgenv().LocalAnim = nil, nil
getgenv().AutoBlockSounds = {
    ["102228729296384"] = true,
    ["140242176732868"] = true,
    ["112809109188560"] = true,
    ["136323728355613"] = true,
    ["115026634746636"] = true,
    ["84116622032112"] = true,
    ["108907358619313"] = true,
    ["127793641088496"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["119942598489800"] = true,
    ["84307400688050"] = true,
    ["113037804008732"] = true,
    ["105200830849301"] = true,
    ["75330693422988"] = true,
    ["82221759983649"] = true,
    ["81702359653578"] = true,
    ["108610718831698"] = true,
    ["112395455254818"] = true,
    ["136323728355613"] = true,
    ["81702359653578"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["109431876587852"] = true,
    ["115026634746636"] = true,
    ["119942598489800"] = true,
    ["109348678063422"] = true,
    ["85853080745515"] = true
}
getgenv().LastAimTime = {}
getgenv().AimDuration = 0.5
getgenv().AimCooldown = 0.6
getgenv().AutoBlockEnabled = false
getgenv().LooseFacingCheck = false
getgenv().SenseRange = 18
getgenv().KnownKillers = {"c00lkidd", "Jason", "JohnDoe", "1x1x1x1", "Noli", "Slasher"}
getgenv().KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
getgenv().CachedGui = LocalGui
getgenv().CachedBlockBtn, CachedPunchBtn, CachedCharges, CachedCD = nil, nil, nil, nil
getgenv().SenseRangeSq = SenseRange * SenseRange
getgenv().RefreshUI = function()
    CachedGui = LocalP:FindFirstChild("PlayerGui") or LocalGui
    local mainUI = CachedGui and CachedGui:FindFirstChild("MainUI")
    if mainUI then
        local abilityContainer = mainUI:FindFirstChild("AbilityContainer")
        CachedBlockBtn = abilityContainer and abilityContainer:FindFirstChild("Clone")
        CachedCD = CachedBlockBtn and CachedBlockBtn:FindFirstChild("CooldownTime")
    else
        CachedBlockBtn, CachedCD = nil, nil
    end
end
RefreshUI()
if CachedGui then
    CachedGui.ChildAdded:Connect(function(child)
        if child.Name == "MainUI" then
            task.delay(0.02, RefreshUI)
        end
    end)
end
LocalP.CharacterAdded:Connect(function()
    task.delay(0.5, RefreshUI)
end)
Combat:CreateSection("007n7 --- Auto Clone Block")
Combat:CreateToggle({
    Name = "Auto Clone Block (Accurate 80%)",
    CurrentValue = false,
    Flag = "AutoBlockAudio",
    Callback = function(state)
        AutoBlockEnabled = state
    end,
})
Combat:CreateInput({
    Name = "Sense Radius",
    PlaceholderText = "18",
    RemoveTextAfterFocusLost = false,
    Flag = "DetectionRange",
    Callback = function(Text)
        SenseRange = tonumber(Text) or SenseRange
        SenseRangeSq = SenseRange * SenseRange
    end
})
getgenv().KillerCircles = {}
getgenv().CirclesVisible = false
getgenv().AddKillerCircle = function(killer)
    if not killer:FindFirstChild("HumanoidRootPart") then return end
    if KillerCircles[killer] then return end
    local circ = Instance.new("CylinderHandleAdornment")
    circ.Name = "KillerDetectionCircle"
    circ.Adornee = killer.HumanoidRootPart
    circ.Color3 = Color3.fromRGB(0, 0, 255)
    circ.AlwaysOnTop = true
    circ.ZIndex = 0
    circ.Transparency = 0.7
    circ.Radius = SenseRange / 1.5
    circ.Height = 0.1
    circ.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    circ.Parent = killer.HumanoidRootPart
    KillerCircles[killer] = circ
end
getgenv().RemoveKillerCircle = function(killer)
    if KillerCircles[killer] then
        KillerCircles[killer]:Destroy()
        KillerCircles[killer] = nil
    end
end
getgenv().RefreshKillerCircles = function()
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        if CirclesVisible then
            AddKillerCircle(killer)
        else
            RemoveKillerCircle(killer)
        end
    end
end
RSvc.RenderStepped:Connect(function()
    for killer, circ in pairs(KillerCircles) do
        if circ and circ.Parent then
            circ.Radius = SenseRange / 1.5
        end
    end
end)
KillersFolder.ChildAdded:Connect(function(killer)
    if CirclesVisible then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then
                AddKillerCircle(killer)
            end
        end)
    end
end)
KillersFolder.ChildRemoved:Connect(function(killer)
    RemoveKillerCircle(killer)
end)
Combat:CreateToggle({
    Name = "Radius Visual",
    CurrentValue = false,
    Flag = "KillerCircleToggle",
    Callback = function(state)
        CirclesVisible = state
        RefreshKillerCircles()
    end
})
getgenv().FacingCheckEnabled = false
Combat:CreateToggle({
    Name = "Directional Facing Check",
    CurrentValue = false,
    Flag = "FacingCheckToggle",
    Callback = function(Value)
        FacingCheckEnabled = Value
    end
})
Combat:CreateDropdown({
    Name = "Directional Facing",
    Options = {"Loose", "Strict"},
    CurrentOption = "Loose",
    Flag = "FacingCheckMode",
    Callback = function(opt) LooseFacingCheck = opt == "Loose" end
})
getgenv().FireBlockRemote = function()
    local args = {"UseActorAbility", {buffer.fromstring("\"Clone\"")}}
    RS:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end
getgenv().IsFacingTarget = function(myRoot, targetRoot)
    if not FacingCheckEnabled then return true end
    local dir = (myRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return LooseFacingCheck and dot > -0.3 or dot > 0
end
getgenv().CachedAnim = nil
getgenv().RefreshAnimator = function()
    local char = LocalP.Character
    if not char then CachedAnim = nil return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    CachedAnim = hum and (hum:FindFirstChildOfClass("Animator") or nil) or nil
end
LocalP.CharacterAdded:Connect(function()
    task.wait(0.5)
    RefreshAnimator()
end)
getgenv().SoundHooks = {}
getgenv().SoundBlockedUntil = {}
getgenv().GetNearestKillerRoot = function(maxDist)
    local kFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not kFolder then return nil end
    local myRoot = LocalP.Character and LocalP.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, minDist = nil, maxDist or math.huge
    for _, k in ipairs(kFolder:GetChildren()) do
        local hrp = k:FindFirstChild("HumanoidRootPart")
        if hrp then
            local d = (hrp.Position - myRoot.Position).Magnitude
            if d < minDist then
                closest, minDist = hrp, d
            end
        end
    end
    return closest
end
getgenv().GetSoundIdNumeric = function(snd)
    if not snd or not snd.SoundId then return nil end
    local sid = tostring(snd.SoundId)
    local num = sid:match("%d+")
    if num then return num end
    return nil
end
getgenv().GetSoundPosition = function(snd)
    if not snd then return nil end
    if snd.Parent and snd.Parent:IsA("BasePart") then
        return snd.Parent.Position, snd.Parent
    end
    if snd.Parent and snd.Parent:IsA("Attachment") and snd.Parent.Parent and snd.Parent.Parent:IsA("BasePart") then
        return snd.Parent.Parent.Position, snd.Parent.Parent
    end
    local found = snd.Parent and snd.Parent:FindFirstChildWhichIsA("BasePart", true)
    return found and found.Position, found or nil, nil
end
getgenv().GetCharFromDescendant = function(inst)
    if not inst then return nil end
    local mdl = inst:FindFirstAncestorOfClass("Model")
    return mdl and mdl:FindFirstChildOfClass("Humanoid") and mdl or nil
end
getgenv().AttemptBlockSound = function(snd)
    if not AutoBlockEnabled then return end
    if not snd or not snd:IsA("Sound") then return end
    if not snd.IsPlaying then return end
    local id = GetSoundIdNumeric(snd)
    if not id or not AutoBlockSounds[id] then return end
    local now = tick()
    if SoundBlockedUntil[snd] and now < SoundBlockedUntil[snd] then return end
    local myRoot = LocalP.Character and LocalP.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local pos, part = GetSoundPosition(snd)
    if not pos or not part then return end
    local char = GetCharFromDescendant(part)
    local plr = char and Plrs:GetPlayerFromCharacter(char)
    if not plr or plr == LocalP then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local dvec = hrp.Position - myRoot.Position
    local distSq = dvec.X^2 + dvec.Y^2 + dvec.Z^2
    if distSq > SenseRangeSq then return end
    if CachedCD and CachedCD.Text ~= "" then return end
    if FacingCheckEnabled and not IsFacingTarget(myRoot, hrp) then return end
    FireBlockRemote()
    SoundBlockedUntil[snd] = now + 1.2
end
getgenv().HookSound = function(snd)
    if not snd or not snd:IsA("Sound") then return end
    if SoundHooks[snd] then return end
    local playConn = snd.Played:Connect(function()
        pcall(AttemptBlockSound, snd)
    end)
    local propConn = snd:GetPropertyChangedSignal("IsPlaying"):Connect(function()
        if snd.IsPlaying then pcall(AttemptBlockSound, snd) end
    end)
    local destroyConn
    destroyConn = snd.Destroying:Connect(function()
        if playConn.Connected then playConn:Disconnect() end
        if propConn.Connected then propConn:Disconnect() end
        if destroyConn.Connected then destroyConn:Disconnect() end
        SoundHooks[snd] = nil
        SoundBlockedUntil[snd] = nil
    end)
    SoundHooks[snd] = {playConn, propConn, destroyConn}
    if snd.IsPlaying then
        task.spawn(function() pcall(AttemptBlockSound, snd) end)
    end
end
for _, d in ipairs(game:GetDescendants()) do
    if d:IsA("Sound") then
        pcall(HookSound, d)
    end
end
game.DescendantAdded:Connect(function(d)
    if d:IsA("Sound") then pcall(HookSound, d) end
end)
local Players = game:GetService("Players")
local player = Players.LocalPlayer
getgenv().blockAnimIds = {
    "72722244508749",
    "72182155407310",
    "95802026624883",
    "98105697395689",
    "82605295530067",
    "115706752305794",
    "96959123077498"
}
getgenv().punchAnimIds = {
    "87259391926321",
    "140703210927645",
    "136007065400978",
    "108911997126897",
    "82137285150006",
    "129843313690921",
    "86709774283672",
    "108807732150251",
    "138040001965654",
    "86096387000557"
}
getgenv().setupAnimationReplacer = function(animationIds)
    local enabled = true
    local ids = {}
    for _, id in ipairs(animationIds) do
        ids[tostring(id)] = true
    end
    local function isTargetAnimation(anim)
        if not anim or not anim.AnimationId then return false end
        local idstr = tostring(anim.AnimationId)
        local num = idstr:match("%d+")
        return num and ids[num]
    end
    local function setupCharacter(char)
        if not char then return end
        local humanoid = char:WaitForChild("Humanoid", 5)
        if not humanoid then return end
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end
        animator.AnimationPlayed:Connect(function(track)
            pcall(function()
                if not enabled then return end
                if not track then return end
                local animObj = track.Animation
                if not animObj then return end
                if isTargetAnimation(animObj) then
                    track:Stop()
                end
            end)
        end)
    end
    if player.Character then
        setupCharacter(player.Character)
    end
    player.CharacterAdded:Connect(setupCharacter)
    return {
        setEnabled = function(state)
            enabled = state
        end
    }
end
getgenv().CreateAnimationInterceptor = function(targetAnimationIds, replacementAnimationId)
    local isEnabled = true
    local targetIdsMap = {}

    for _, id in ipairs(targetAnimationIds) do
        targetIdsMap[tostring(id)] = true
    end

    local function isTargetAnimation(animation)
        if not animation or not animation.AnimationId then return false end
        local idStr = tostring(animation.AnimationId)
        local idNum = idStr:match("%d+")
        return idNum and targetIdsMap[idNum]
    end

    local function setupCharacterInterceptor(character)
        if not character then return end

        local humanoid = character:WaitForChild("Humanoid", 5)
        if not humanoid then return end

        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end

        animator.AnimationPlayed:Connect(function(originalTrack)
            pcall(function()
                if not isEnabled or not originalTrack then return end

                local originalAnimation = originalTrack.Animation
                if not isTargetAnimation(originalAnimation) then return end

                local originalDuration = originalTrack.Length or 1
                originalTrack:Stop()

                if replacementAnimationId then
                    local replacementAnim = Instance.new("Animation")
                    replacementAnim.AnimationId = "rbxassetid://" .. tostring(replacementAnimationId)
                    local replacementTrack = animator:LoadAnimation(replacementAnim)
                    replacementTrack:Play()

                    task.delay(originalDuration, function()
                        if replacementTrack.IsPlaying then
                            replacementTrack:Stop()
                        end
                    end)
                end
            end)
        end)
    end

    if player.Character then
        setupCharacterInterceptor(player.Character)
    end

    player.CharacterAdded:Connect(setupCharacterInterceptor)

    return {
        SetEnabled = function(state)
            isEnabled = state
        end
    }
end
Combat:CreateSection("Guest 1337 --- Ragebait")
getgenv().invisibleBlock = getgenv().setupAnimationReplacer(blockAnimIds)
Combat:CreateToggle({
    Name = "Invisible Block",
    CurrentValue = false,
    Flag = "InvisibleBlockToggle",
    Callback = function(value)
        invisibleBlock.setEnabled(value)
    end
})
getgenv().invisiblePunch = getgenv().setupAnimationReplacer(punchAnimIds)
Combat:CreateToggle({
    Name = "Invisible Punch",
    CurrentValue = false,
    Flag = "InvisiblePunchToggle",
    Callback = function(value)
        invisiblePunch.setEnabled(value)
    end
})
local replacementPunchId = "109589533330665"
getgenv().slashPunchAnimGuest = false
getgenv().slasherPunch = getgenv().CreateAnimationInterceptor(punchAnimIds, replacementPunchId)
Combat:CreateToggle({
    Name = "Punch Animation (Slasher Punch)",
    CurrentValue = false,
    Flag = "SlasherPunch",
    Callback = function(enabled)
		getgenv().slashPunchAnimGuest = enabled
        slasherPunch.SetEnabled(enabled)
    end
})

getgenv().Players = game:GetService("Players")
getgenv().RunService = game:GetService("RunService")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().player = Players.LocalPlayer
getgenv().character = player.Character or player.CharacterAdded:Wait()
getgenv().humanoid = character:WaitForChild("Humanoid")
getgenv().rootPart = character:WaitForChild("HumanoidRootPart")
getgenv().camera = workspace.CurrentCamera
getgenv().MovementEnabled = false
getgenv().runAnimId = "rbxassetid://136252471123500"
getgenv().walkAnimId = "rbxassetid://108018357044094"
getgenv().idleAnimId = "rbxassetid://131082534135875"
getgenv().runAnimObj = Instance.new("Animation")
runAnimObj.AnimationId = runAnimId
getgenv().walkAnimObj = Instance.new("Animation")
walkAnimObj.AnimationId = walkAnimId
getgenv().idleAnimObj = Instance.new("Animation")
idleAnimObj.AnimationId = idleAnimId
getgenv().runTrack = humanoid:LoadAnimation(runAnimObj)
getgenv().walkTrack = humanoid:LoadAnimation(walkAnimObj)
getgenv().idleTrack = humanoid:LoadAnimation(idleAnimObj)
getgenv().runSpeed = 1
getgenv().lastMoveDir = Vector3.new()
getgenv().isTurning = false
local function setupCharacter(char)
    getgenv().character = char
    getgenv().humanoid = char:WaitForChild("Humanoid")
    getgenv().rootPart = char:WaitForChild("HumanoidRootPart")
    getgenv().runTrack = humanoid:LoadAnimation(runAnimObj)
    getgenv().walkTrack = humanoid:LoadAnimation(walkAnimObj)
    getgenv().idleTrack = humanoid:LoadAnimation(idleAnimObj)
end
if not getgenv().sprintModule then
    getgenv().sprintModule = require(ReplicatedStorage.Systems.Character.Game.Sprinting)
end
RunService.Heartbeat:Connect(function()
    if not getgenv().MovementEnabled then return end
    if character.Name ~= "007n7" then return end
    local moveDir = humanoid.MoveDirection
    if moveDir.Magnitude > 0 then
        if idleTrack.IsPlaying then idleTrack:Stop(0) end
		if lastMoveDir.Magnitude > 0 and moveDir:Dot(lastMoveDir) < 0.9 and not isTurning then
			isTurning = true
			local startTime = tick()
			local duration = 0.08
			while tick() - startTime < duration do
				rootPart.CFrame = rootPart.CFrame:Lerp(
					CFrame.new(rootPart.Position, rootPart.Position + moveDir.Unit),
					0.5
				)
				RunService.Heartbeat:Wait()
			end
			rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + moveDir.Unit)
			isTurning = false
        elseif not runTrack.IsPlaying and not isTurning then
            runTrack:Play(0)
            runTrack:AdjustSpeed(runSpeed)
            runTrack.TimePosition = 0
            rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + moveDir.Unit)
        end
        lastMoveDir = moveDir.Unit
    else
        if runTrack.IsPlaying then runTrack:Stop(0) end
        if not idleTrack.IsPlaying then
            idleTrack:Play(0)
            idleTrack.TimePosition = 0
        end
        lastMoveDir = Vector3.new()
    end
    if not sprintModule.IsSprinting then
        sprintModule.IsSprinting = true
        sprintModule.__sprintedEvent:Fire(true)
    end
end)
player.CharacterAdded:Connect(function(char)
    setupCharacter(char)
end)
if player.Character then
    setupCharacter(player.Character)
end
Combat:CreateSection("007n7 --- Ragebait")
Combat:CreateToggle({
    Name = "Fake Clone Moving",
    CurrentValue = false,
    Flag = "MovementToggle",
    Callback = function(value)
        getgenv().MovementEnabled = value
    end
})
local savedRangeRaging = Players.LocalPlayer:FindFirstChild("RagingPaceRange")
if not savedRangeRaging then
    savedRangeRaging = Instance.new("NumberValue")
    savedRangeRaging.Name = "RagingPaceRange"
    savedRangeRaging.Value = 19
    savedRangeRaging.Parent = Players.LocalPlayer
end
local savedRange404 = Players.LocalPlayer:FindFirstChild("Error404Range")
if not savedRange404 then
    savedRange404 = Instance.new("NumberValue")
    savedRange404.Name = "Error404Range"
    savedRange404.Value = 19
    savedRange404.Parent = Players.LocalPlayer
end
local savedRangeCorrupt = Players.LocalPlayer:FindFirstChild("CorruptEnergyRange")
if not savedRangeCorrupt then
    savedRangeCorrupt = Instance.new("NumberValue")
    savedRangeCorrupt.Name = "CorruptEnergyRange"
    savedRangeCorrupt.Value = 19
    savedRangeCorrupt.Parent = Players.LocalPlayer
end
local RANGE_RAGING = savedRangeRaging.Value
local RANGE_404 = savedRange404.Value
local RANGE_CORRUPT = savedRangeCorrupt.Value
local SPAM_DURATION = 3
local COOLDOWN_TIME = 5
local activeCooldownsRaging = {}
local activeCooldowns404 = {}
local activeCooldownsCorrupt = {}
local enabledRaging = false
local enabled404 = false
local enabledCorrupt = false
local animsToDetectRaging = {
    ["72722244508749"] = false,
    ["77448521277146"] = true,
    ["86096387000557"] = true,
    ["86371356500204"] = true,
    ["86545133269813"] = true,
    ["86709774283672"] = true,
    ["87259391926321"] = true,
    ["89448354637442"] = true,
    ["96959123077498"] = false,
    ["103601716322988"] = true,
    ["108807732150251"] = true,
    ["115194624791339"] = true,
    ["116618003477002"] = true,
    ["119462383658044"] = true,
    ["121255898612475"] = true,
    ["131696603025265"] = true,
    ["133491532453922"] = true,
    ["136007065400978"] = true,
    ["138040001965654"] = true,
    ["140703210927645"] = true,
}
local animsToDetect404 = animsToDetectRaging
local animsToDetectCorrupt = animsToDetectRaging
local function fireSkill(skillName)
    local args = {"UseActorAbility", { buffer.fromstring("\""..skillName.."\"")}}
    ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end
local function isAnimationMatching(anim, animTable)
    if not anim or not anim.Animation then
        return false
    end
    local id = anim.Animation.AnimationId
    if type(id) ~= "string" then
        return false
    end
    local numId = id:match("%d+")
    if not numId then
        return false
    end
    return animTable[numId] == true
end
local function detectAndSpam(skillName, range, cooldownTable, animTable)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = player.Character.HumanoidRootPart
            local myChar = Players.LocalPlayer.Character
            if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                local dist = (targetHRP.Position - myChar.HumanoidRootPart.Position).Magnitude
                if dist <= range and (not cooldownTable[player] or tick() - cooldownTable[player] >= COOLDOWN_TIME) then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
                            if isAnimationMatching(track, animTable) then
                                cooldownTable[player] = tick()
                                task.spawn(function()
                                    local startTime = tick()
                                    while tick() - startTime < SPAM_DURATION do
                                        fireSkill(skillName)
                                        task.wait(0.05)
                                    end
                                end)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end
RunService.RenderStepped:Connect(function()
    if enabledRaging then
        detectAndSpam("RagingPace", RANGE_RAGING, activeCooldownsRaging, animsToDetectRaging)
    end
    if enabled404 then
        detectAndSpam("404Error", RANGE_404, activeCooldowns404, animsToDetect404)
    end
    if enabledCorrupt then
        detectAndSpam("CorruptEnergy", RANGE_CORRUPT, activeCooldownsCorrupt, animsToDetectCorrupt)
    end
end)
Combat:CreateSection("Killers Parry")
Combat:CreateToggle({
    Name = "Raging Pace Parry",
    CurrentValue = false,
    Flag = "RagingPaceToggle",
    Callback = function(Value)
        enabledRaging = Value
    end,
})
Combat:CreateInput({
    Name = "Raging Pace Range (studs)",
    Flag = "RagingPaceRangestuds",
    PlaceholderText = tostring(RANGE_RAGING),
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local num = tonumber(Text)
        if num and num > 0 then
            RANGE_RAGING = num
            savedRangeRaging.Value = num
        end
    end,
})
Combat:CreateToggle({
    Name = "404Error Parry",
    CurrentValue = false,
    Flag = "Error404Toggle",
    Callback = function(Value)
        enabled404 = Value
    end,
})
Combat:CreateInput({
    Name = "404Error Range (studs)",
    Flag = "404ErrorRangestuds",
    PlaceholderText = tostring(RANGE_404),
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local num = tonumber(Text)
        if num and num > 0 then
            RANGE_404 = num
            savedRange404.Value = num
        end
    end,
})
Combat:CreateToggle({
    Name = "Corrupt Energy Parry",
    CurrentValue = false,
    Flag = "CorruptEnergyToggle",
    Callback = function(Value)
        enabledCorrupt = Value
    end,
})
Combat:CreateInput({
    Name = "Corrupt Energy Range (studs)",
    Flag = "CorruptEnergyRangestuds",
    PlaceholderText = tostring(RANGE_CORRUPT),
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local num = tonumber(Text)
        if num and num > 0 then
            RANGE_CORRUPT = num
            savedRangeCorrupt.Value = num
        end
    end,
})
local char = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
Players.LocalPlayer.CharacterAdded:Connect(function(v)
	char = v
end)
getgenv().device = getgenv().player:GetAttribute("Device")
if type(getgenv().device) == "table" then
    getgenv().device = getgenv().device[1]
end
getgenv().device = tostring(getgenv().device or "PC")
getgenv().originalDevice = getgenv().device
getgenv().spoofDeviceEnabled = false
getgenv().selectedDevice = getgenv().device
Miscs:CreateSection("Device")
Miscs:CreateToggle({
    Name = "Enable Spoof Device",
    CurrentValue = getgenv().spoofDeviceEnabled,
    Flag = "SpoofDeviceToggle",
    Callback = function(state)
        getgenv().spoofDeviceEnabled = state
        if state then
            if getgenv().heartbeatConn then
                getgenv().heartbeatConn:Disconnect()
            end
            getgenv().heartbeatConn = RunService.Heartbeat:Connect(function()
                getgenv().device = getgenv().selectedDevice
                getgenv().RemoteEvent:FireServer("SetDevice", {
                    buffer.fromstring("\""..getgenv().device.."\"")
                })
            end)
        else
            if getgenv().heartbeatConn then
                getgenv().heartbeatConn:Disconnect()
                getgenv().heartbeatConn = nil
            end
            getgenv().device = getgenv().originalDevice
            getgenv().RemoteEvent:FireServer("SetDevice", {
                buffer.fromstring("\""..getgenv().device.."\"")
            })
        end
    end,
})
Miscs:CreateDropdown({
    Name = "Select Device",
    Flag = "SpoofDevice",
    Options = {"PC", "Mobile", "Console"},
    CurrentOption = {getgenv().selectedDevice},
    MultipleOptions = false,
    Callback = function(selectedOption)
        local selected = selectedOption[1]
        getgenv().selectedDevice = selected
        if getgenv().spoofDeviceEnabled then
            getgenv().device = selected
            getgenv().RemoteEvent:FireServer("SetDevice",{buffer.fromstring("\""..selected.."\"")})
        end
    end,
})
Miscs:CreateSection("Footsteps")
Miscs:CreateToggle({
    Name = "Anti Footsteps",
    CurrentValue = false,
    Flag = "AntiFootsteps",
    Callback = function(value)
		if value then
			getgenv().HookFootstepPlayed(true)
		else
			getgenv().HookFootstepPlayed(false)
        end
    end,
})
getgenv().Players = game:GetService("Players")
getgenv().LocalPlayer = getgenv().Players.LocalPlayer
getgenv().originalValues = {}
getgenv().paths = {
    "HideKillerWins",
    "HidePlaytime",
    "HideSurvivorWins"
}
getgenv().toggleState = false
getgenv().saveOriginalValues = function(player)
    if player == getgenv().LocalPlayer then return end
    if not getgenv().originalValues[player.UserId] then
        getgenv().originalValues[player.UserId] = {}
    end
    for _, key in ipairs(getgenv().paths) do
        local value = player:FindFirstChild("PlayerData")
            and player.PlayerData:FindFirstChild("Settings")
            and player.PlayerData.Settings:FindFirstChild("Privacy")
            and player.PlayerData.Settings.Privacy:FindFirstChild(key)
        if value then
            getgenv().originalValues[player.UserId][key] = value.Value
        end
    end
end
getgenv().setAllFalse = function(player)
    if player == getgenv().LocalPlayer then return end
    for _, key in ipairs(getgenv().paths) do
        local value = player:FindFirstChild("PlayerData")
            and player.PlayerData:FindFirstChild("Settings")
            and player.PlayerData.Settings:FindFirstChild("Privacy")
            and player.PlayerData.Settings.Privacy:FindFirstChild(key)
        if value then
            value.Value = false
        end
    end
end
getgenv().restoreValues = function(player)
    if player == getgenv().LocalPlayer then return end
    if getgenv().originalValues[player.UserId] then
        for key, val in pairs(getgenv().originalValues[player.UserId]) do
            local value = player:FindFirstChild("PlayerData")
                and player.PlayerData:FindFirstChild("Settings")
                and player.PlayerData.Settings:FindFirstChild("Privacy")
                and player.PlayerData.Settings.Privacy:FindFirstChild(key)
            if value then
                value.Value = val
            end
        end
    end
end
getgenv().togglePrivacy = function(disable)
    for _, player in ipairs(getgenv().Players:GetPlayers()) do
        if player ~= getgenv().LocalPlayer then
            if disable then
                getgenv().saveOriginalValues(player)
                getgenv().setAllFalse(player)
            else
                getgenv().restoreValues(player)
            end
        end
    end
    getgenv().toggleState = disable
end
getgenv().Players.PlayerAdded:Connect(function(player)
    if player ~= getgenv().LocalPlayer and getgenv().toggleState == true then
        getgenv().saveOriginalValues(player)
        getgenv().setAllFalse(player)
    end
end)
Miscs:CreateToggle({
    Name = "Allow Killer Entrances",
    CurrentValue = false,
    Flag = "AllowKillerEntrances",
    Callback = function(Value)
        _G.killerent = Value
        getgenv().restoreWalls = function()
            local map = workspace:FindFirstChild("Map")
            if map and map:FindFirstChild("Ingame") and map.Ingame:FindFirstChild("Map") then
                local walls = map.Ingame.Map:FindFirstChild("Killer_Only Wall") or map.Ingame.Map:FindFirstChild("KillerOnlyEntrances")
                if walls then
                    for _, wall in pairs(walls:GetChildren()) do
                        wall.CanCollide = true
                    end
                end
            end
        end
        if not _G.killerent then
            pcall(getgenv().restoreWalls)
            return
        end
        task.spawn(function()
            while _G.killerent do
                local map = workspace:FindFirstChild("Map")
                if map and map:FindFirstChild("Ingame") and map.Ingame:FindFirstChild("Map") then
                    local entrances = map.Ingame.Map:FindFirstChild("KillerOnlyEntrances")
                    if entrances then
                        for _, v in pairs(entrances:GetChildren()) do
                            v.CanCollide = false
                        end
                    end
                end
                task.wait(0.1)
            end
        end)
    end
})
Miscs:CreateSection("Bright")
getgenv().Lighting = game:GetService("Lighting")
getgenv().RunService = game:GetService("RunService")
getgenv().brightLoop = nil
Miscs:CreateToggle({
    Name = "Full Brightness",
    CurrentValue = false,
    Flag = "BrightToggle",
    Callback = function(Value)
        if Value then
            getgenv().brightLoop = RunService.RenderStepped:Connect(function()
                Lighting.Brightness = 2
                Lighting.ClockTime = 14
                Lighting.FogEnd = 100000
                Lighting.GlobalShadows = false
                Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
                for i,v in pairs(Lighting:GetDescendants()) do
                    if v:IsA("Atmosphere") then
                        v:Destroy()
                    end
                end
            end)
        else
            if getgenv().brightLoop then
                getgenv().brightLoop:Disconnect()
                getgenv().brightLoop = nil
            end
            Lighting.Brightness = 1
            Lighting.ClockTime = 12
            Lighting.FogEnd = 1000
            Lighting.GlobalShadows = true
            Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)
        end
    end,
})
Miscs:CreateSection("Stats")
Miscs:CreateToggle({
    Name = "Anti Hidden Stats",
    CurrentValue = false,
    Flag = "AntiHiddenStats",
    Callback = function(value)
		if value then
			getgenv().togglePrivacy(true)
		else
			getgenv().togglePrivacy(false)
        end
    end,
})
Miscs:CreateSection("FOV")
Miscs:CreateInput({
    Name = "Input FOV",
    PlaceholderText = "80",
    RemoveTextAfterFocusLost = false,
    Flag = "FOVInput",
    Callback = function(thefoxtext)
		local fovvalueinput = tonumber(thefoxtext)
		if fovvalueinput then
			local args = {
				"UpdateSettings",
				{
					game:GetService("Players").LocalPlayer
						:WaitForChild("PlayerData")
						:WaitForChild("Settings")
						:WaitForChild("Game")
						:WaitForChild("FieldOfView"),
					buffer.fromstring(tostring(fovvalueinput))
				}
			}
			game:GetService("ReplicatedStorage")
				:WaitForChild("Modules")
				:WaitForChild("Network")
				:WaitForChild("RemoteEvent")
				:FireServer(unpack(args))
		end
    end,
})
getgenv().Players = game:GetService("Players")
getgenv().LocalPlayer = getgenv().Players.LocalPlayer
getgenv().Workspace = game:GetService("Workspace")
getgenv().BlinkToPizzaToggle = false
getgenv().HPThreshold = 30
getgenv().getHRP = function()
    local char = getgenv().LocalPlayer.Character or getgenv().LocalPlayer.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end
getgenv().getHP = function()
    local char = getgenv().LocalPlayer.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then return hum.Health end
    end
    return 0
end
getgenv().getPizzaCF = function()
    local pizzaFolder = getgenv().Workspace:FindFirstChild("Map") and getgenv().Workspace.Map:FindFirstChild("Ingame")
    if not pizzaFolder then return nil end
    local pizza = pizzaFolder:FindFirstChild("Pizza")
    if not pizza then return nil end
    if pizza:IsA("BasePart") or pizza:IsA("MeshPart") or pizza:IsA("UnionOperation") then
        return pizza.CFrame
    elseif pizza:IsA("Model") then
        local pp = pizza.PrimaryPart or pizza:FindFirstChildWhichIsA("BasePart")
        if pp then
            if not pizza.PrimaryPart then pizza.PrimaryPart = pp end
            return pp.CFrame
        end
    elseif pizza:IsA("CFrameValue") then
        return pizza.Value
    end
end
Miscs:CreateSection("Pizza")
Miscs:CreateToggle({
    Name = "Auto Eat Pizza Instantly",
    CurrentValue = false,
    Flag = "BlinkToggle",
    Callback = function(Value)
        getgenv().BlinkToPizzaToggle = Value
    end
})
Miscs:CreateInput({
    Name = "HP Threshold",
    Flag = "HPThreshold",
    PlaceholderText = "30",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            getgenv().HPThreshold = num
        end
    end
})
spawn(function()
    while task.wait(0.9) do
        if getgenv().BlinkToPizzaToggle then
            local hrp = getgenv().getHRP()
            local pizzaCF = getgenv().getPizzaCF()
            if pizzaCF and getgenv().getHP() <= getgenv().HPThreshold then
                local oldCF = hrp.CFrame
                hrp.CFrame = pizzaCF * CFrame.new(0,1,0)
                getgenv().activateRemoteHook("UnreliableRemoteEvent", "UpdCF")
                task.delay(0.2, function()
                    hrp.CFrame = oldCF
                    task.wait(0.3)
                    getgenv().deactivateRemoteHook("UnreliableRemoteEvent", "UpdCF")
                end)
            end
        end
    end
end)
Miscs:CreateSection("Items")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().Players = game:GetService("Players")
getgenv().LocalPlayer = Players.LocalPlayer
getgenv().autoPickupEnabled = false
getgenv().droppedTools = {}
getgenv().hasDropped = false
local function isAlive(char)
	return char and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0
end
local function dropAllTools(char)
	if not char then return end
	table.clear(droppedTools)
	for _, v in ipairs(LocalPlayer.Backpack:GetChildren()) do
		if v:IsA("Tool") then
			table.insert(droppedTools, v.Name)
			v.Parent = workspace
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:IsA("Tool") then
			table.insert(droppedTools, v.Name)
			v.Parent = workspace
		end
	end
	hasDropped = true
end
LocalPlayer.CharacterAdded:Connect(function(char)
	hasDropped = false
	char:WaitForChild("Humanoid").Died:Connect(function()
		if autoPickupEnabled then
			dropAllTools(char)
		end
	end)
end)
task.spawn(function()
	while task.wait() do
		local char = LocalPlayer.Character
		if autoPickupEnabled and isAlive(char) then
			local mapIngame = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
			if mapIngame then
				for _, tool in ipairs(mapIngame:GetChildren()) do
					if tool:IsA("Tool") and char:FindFirstChild("Humanoid") then
						char.Humanoid:EquipTool(tool)
					end
				end
			end
			for _, toolName in ipairs(droppedTools) do
				local found = workspace:FindFirstChild(toolName, true)
				if found and found:IsA("Tool") and char:FindFirstChild("Humanoid") then
					char.Humanoid:EquipTool(found)
				end
			end
		end
	end
end)
Miscs:CreateToggle({
	Name = "Auto Pickup Drop Items",
	CurrentValue = false,
	Flag = "AutoPickupTool",
	Callback = function(Value)
		autoPickupEnabled = Value
	end,
})
_G.pickUpNear = false
_G.pickUpAll = false
local trackedItems = {}
local function trackTool(tool)
	if tool:IsA("Tool") and tool:FindFirstChild("ItemRoot") then
		table.insert(trackedItems, tool.ItemRoot)
	end
end
local function untrackTool(tool)
	if tool:IsA("Tool") and tool:FindFirstChild("ItemRoot") then
		for i, v in ipairs(trackedItems) do
			if v == tool.ItemRoot then
				table.remove(trackedItems, i)
				break
			end
		end
	end
end
local function initTrack()
	trackedItems = {}
	local map = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
	if map then
		for _, v in ipairs(map:GetDescendants()) do
			trackTool(v)
		end
		map.DescendantAdded:Connect(trackTool)
		map.DescendantRemoving:Connect(untrackTool)
	end
end
initTrack()
local function autoPickUpLoop()
	while task.wait() do
		if not _G.pickUpNear and not _G.pickUpAll then break end
		pcall(function()
			local char = LocalPlayer.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			if not (char and char.Parent and char.Parent.Name == "Survivors") then
				return
			end
			if not hrp then return end
			for _, v in ipairs(trackedItems) do
				if v and v.Parent then
					if _G.pickUpNear then
						if (hrp.Position - v.Position).Magnitude <= 10 then
							fireproximityprompt(v.ProximityPrompt)
						end
					end
					if _G.pickUpAll then
						if not LocalPlayer.Backpack:FindFirstChild(v.Parent.Name) then
							hrp.CFrame = v.CFrame
							task.wait()
							fireproximityprompt(v.ProximityPrompt)
						end
					end
				end
			end
		end)
	end
end
Miscs:CreateToggle({
	Name = "Auto Pick Up Near Items",
	CurrentValue = false,
	Flag = "AutoPickUpItems",
	Callback = function(call)
		_G.pickUpNear = call
		if call then
			task.spawn(autoPickUpLoop)
		end
	end,
})
Miscs:CreateToggle({
	Name = "Auto Pick Up All Items",
	CurrentValue = false,
	Flag = "AutoPickUpAll",
	Callback = function(call)
		_G.pickUpAll = call
		if call then
			task.spawn(autoPickUpLoop)
		end
	end,
})
Miscs:CreateSection("Invisibility")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local animationId = "75804462760596"
local animationSpeed = 0
local currentAnim = nil
local loopRunning = false
local function setInvisibility(state)
    local speaker = LocalPlayer
    if not speaker or not speaker.Character then return end
    local parent = speaker.Character.Parent
    if not parent or (parent.Name ~= "Survivors" and parent.Name ~= "Killers") then
        return
    end
    local humanoid = speaker.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.RigType ~= Enum.HumanoidRigType.R6 then
        Rayfield:Notify({
            Title = "R6 Required",
            Content = "This only works with R6 rig!",
            Duration = 5
        })
        return
    end
    if state then
        loopRunning = true
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. animationId
        currentAnim = humanoid:LoadAnimation(anim)
        currentAnim.Looped = true
        currentAnim:Play()
        currentAnim:AdjustSpeed(animationSpeed)
    else
        loopRunning = false
        if currentAnim then
            currentAnim:Stop()
            currentAnim = nil
        end
        local Humanoid = speaker.Character:FindFirstChildOfClass("Humanoid")
                        or speaker.Character:FindFirstChildOfClass("AnimationController")
        if Humanoid then
            for _, v in pairs(Humanoid:GetPlayingAnimationTracks()) do
                v:AdjustSpeed(100000)
            end
        end
        local animateScript = speaker.Character:FindFirstChild("Animate")
        if animateScript then
            animateScript.Disabled = true
            animateScript.Disabled = false
        end
    end
end
Miscs:CreateToggle({
   Name = "Invisibility",
   CurrentValue = false,
   Flag = "ToggleAnimLoop",
   Callback = function(Value)
      setInvisibility(Value)
   end,
})
LocalPlayer.CharacterAdded:Connect(function(char)
    if loopRunning then
        task.wait()
        setInvisibility(true)
    end
end)
Miscs:CreateToggle({
    Name = "CFrame Ghosting (OP)",
    CurrentValue = false,
    Callback = function(state)
        if state then
            getgenv().activateRemoteHook("UnreliableRemoteEvent", "UpdCF")
			local args = {
				"UpdateSettings",
				{
					game:GetService("Players").LocalPlayer:WaitForChild("PlayerData"):WaitForChild("Settings"):WaitForChild("Advanced"):WaitForChild("ShowPlayerHitboxes"),
					buffer.fromstring("true")
				}
			}
			game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
        else
            getgenv().deactivateRemoteHook("UnreliableRemoteEvent", "UpdCF")
			local args = {
				"UpdateSettings",
				{
					game:GetService("Players").LocalPlayer:WaitForChild("PlayerData"):WaitForChild("Settings"):WaitForChild("Advanced"):WaitForChild("ShowPlayerHitboxes"),
					buffer.fromstring("false")
				}
			}
			game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
        end
    end
})
getgenv().Players = game:GetService("Players")
getgenv().MarketplaceService = game:GetService("MarketplaceService")
getgenv().RunService = game:GetService("RunService")
getgenv().player = getgenv().Players.LocalPlayer
getgenv().replacementAnimations = {
    idle = "rbxassetid://134624270247120",
    walk = "rbxassetid://132377038617766",
    run  = "rbxassetid://115946474977409"
}
getgenv().animationNameCache = {}
getgenv()._animReplaceState = getgenv()._animReplaceState or {}
getgenv().fakeinjuredanimation = false
local function parseAssetId(str)
    if not str then return nil end
    local id = tostring(str):match("(%d+)")
    return id and tonumber(id) or nil
end
getgenv().getAnimationNameFromId = function(assetId)
    if not assetId then return nil end
    if getgenv().animationNameCache[assetId] then
        return getgenv().animationNameCache[assetId]
    end
    local ok, info = pcall(function()
        return getgenv().MarketplaceService:GetProductInfo(assetId, Enum.InfoType.Asset)
    end)
    if ok and info and info.Name then
        getgenv().animationNameCache[assetId] = info.Name
        return info.Name
    end
    return nil
end
getgenv().playReplacementAnimation = function(animator, animType)
    if not animator or not getgenv().replacementAnimations[animType] then return nil end
    local anim = Instance.new("Animation")
    anim.Name = ("__replacement_%s"):format(animType)
    anim.AnimationId = getgenv().replacementAnimations[animType]
    local success, track = pcall(function()
        return animator:LoadAnimation(anim)
    end)
    if not success or not track then
        return nil
    end
    track.Priority = Enum.AnimationPriority.Movement
    track:Play()
    return track
end
local function disconnectIfAlive(conn)
    if conn and typeof(conn) == "RBXScriptConnection" then
        conn:Disconnect()
    end
end
getgenv().setupCharacter = function(char)
    if not char then return end
    local humanoid = char:WaitForChild("Humanoid")
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end
    local state = getgenv()._animReplaceState[char]
    if state then
        disconnectIfAlive(state.heartbeatConn)
        disconnectIfAlive(state.playedConn)
        if state.currentTrack and state.currentTrack.IsPlaying then
            pcall(function() state.currentTrack:Stop() end)
        end
    end
    state = {
        animator = animator,
        humanoid = humanoid,
        currentTrack = nil,
        currentType = nil,
        heartbeatConn = nil,
        playedConn = nil
    }
    getgenv()._animReplaceState[char] = state
    local replSet = {}
    for k,v in pairs(getgenv().replacementAnimations) do
        local id = parseAssetId(v)
        if id then replSet[id] = true end
    end
    state.replSet = replSet
    state.heartbeatConn = getgenv().RunService.Heartbeat:Connect(function()
        if not getgenv().fakeinjuredanimation then return end
        local track = state.currentTrack
        if track and state.currentType and track.IsPlaying then
            local ws = math.clamp(state.humanoid.WalkSpeed or 16, 0, 100)
            if state.currentType == "idle" then
                pcall(function() track:AdjustSpeed(1) end)
            elseif state.currentType == "walk" then
                pcall(function() track:AdjustSpeed(math.max(ws / 12, 0.2)) end)
            elseif state.currentType == "run" then
                pcall(function() track:AdjustSpeed(math.max(ws / 26, 0.2)) end)
            end
        end
    end)
    state.playedConn = animator.AnimationPlayed:Connect(function(track)
        if not getgenv().fakeinjuredanimation then return end
        if not track or not track.Animation then return end
        local animationIdStr = tostring(track.Animation.AnimationId or "")
        local assetId = parseAssetId(animationIdStr)
        if assetId and state.replSet[assetId] then
            return
        end
        if state.currentTrack == track then
            return
        end
        local animName = nil
        if assetId then
            animName = getgenv().getAnimationNameFromId(assetId)
        end
        if not animName then
            animName = animationIdStr
        end
        if type(animName) == "string" then
            local lowerName = animName:lower()
            if lowerName:find("idle") then
                if state.currentTrack then pcall(function() state.currentTrack:Stop() end) end
                local newTrack = getgenv().playReplacementAnimation(animator, "idle")
                if newTrack then
                    state.currentTrack = newTrack
                    state.currentType = "idle"
                end
            elseif lowerName:find("walk") then
                if state.currentTrack then pcall(function() state.currentTrack:Stop() end) end
                local newTrack = getgenv().playReplacementAnimation(animator, "walk")
                if newTrack then
                    state.currentTrack = newTrack
                    state.currentType = "walk"
                end
            elseif lowerName:find("run") then
                if state.currentTrack then pcall(function() state.currentTrack:Stop() end) end
                local newTrack = getgenv().playReplacementAnimation(animator, "run")
                if newTrack then
                    state.currentTrack = newTrack
                    state.currentType = "run"
                end
            end
        end
    end)
end
getgenv().player.CharacterRemoving:Connect(function(char)
    local state = getgenv()._animReplaceState[char]
    if state then
        disconnectIfAlive(state.heartbeatConn)
        disconnectIfAlive(state.playedConn)
        if state.currentTrack then pcall(function() state.currentTrack:Stop() end) end
        getgenv()._animReplaceState[char] = nil
    end
end)
if getgenv().player.Character then
    getgenv().setupCharacter(getgenv().player.Character)
end
getgenv().player.CharacterAdded:Connect(getgenv().setupCharacter)
Miscs:CreateSection("Animations")
Miscs:CreateToggle({
    Name = "Fake Injured Animations",
    CurrentValue = false,
    Flag = "CustomAnimationsToggle",
    Callback = function(value)
        getgenv().fakeinjuredanimation = value
        if not value then
            for char, state in pairs(getgenv()._animReplaceState) do
                if state.currentTrack then
                    pcall(function() state.currentTrack:Stop() end)
                    state.currentTrack = nil
                    state.currentType = nil
                end
            end
        end
    end
})
Miscs:CreateSection("1x1x1x1")
Miscs:CreateToggle({
    Name = "Auto Close 1x1x1x1 Popups",
    CurrentValue = false,
    Flag = "Toggle_1x1Popup",
    Callback = function(Value)
        DoLoop = Value
        task.spawn(function()
            local player = game:GetService("Players").LocalPlayer
            local Survivors = workspace:WaitForChild("Players"):WaitForChild("Survivors")
            while DoLoop and task.wait() do
                local temp = player.PlayerGui:FindFirstChild("TemporaryUI")
                if temp and temp:FindFirstChild("1x1x1x1Popup") then
                    temp["1x1x1x1Popup"]:Destroy()
                end
                for _, survivor in pairs(Survivors:GetChildren()) do
                    if survivor:GetAttribute("Username") == player.Name then
                        local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
                        if speedMultipliers then
                            local val = speedMultipliers:FindFirstChild("SlowedStatus")
                            if val and val:IsA("NumberValue") then
                                val.Value = 1
                            end
                        end
                        local fovMultipliers = survivor:FindFirstChild("FOVMultipliers")
                        if fovMultipliers then
                            local val = fovMultipliers:FindFirstChild("SlowedStatus")
                            if val and val:IsA("NumberValue") then
                                val.Value = 1
                            end
                        end
                    end
                end
            end
        end)
    end
})
Miscs:CreateSection("FPS Booster")
Miscs:CreateButton({
   Name = "Load FPS Booster",
    Flag = "LoadFPSBooster",
   Callback = function()
       loadstring(game:HttpGet("https://raw.githubusercontent.com/JoshzzAlteregooo/JoshzzFpsBoosterVersion3/refs/heads/main/JoshzzNewFpsBooster"))()
   end
})
getgenv().SoundService = game:GetService("SoundService")
getgenv().RunService = game:GetService("RunService")
getgenv().Players = game:GetService("Players")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().LocalPlayer = Players.LocalPlayer
getgenv().NetworkEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local folderPath = "Nyansaken/Assets"
if not isfolder("Nyansaken") then makefolder("Nyansaken") end
if not isfolder(folderPath) then makefolder(folderPath) end
getgenv().orderedTrackKeys = {
    "None",
    "----------- UST -----------",
    "A BRAVE SOUL (MS 4 Killer VS MS 4 Survivor)",
    "BEGGED (MS 4 Coolkidd vs MS 4 007n7)",
    "DOOMSPIRE (HairyTwinkle VS Pedro.EXE)",
    "ECLIPSE (xX4ce0fSpadesXx vs dragondudes3)",
    "ERROR 264 (Noob Cosplay VS Yourself)",
    "GODS SECOND COMING (NOLI VS. 007n7)",
    "Entreat (Bluudude Vs 118o8)",
    "Implore (Comic vs Savior)",
    "Leftovers (Remix Vanity Jason Vs All)",
    "ORDER UP (Elliot VS c00lkidd)",
    "PARADOX (Guest 666 Vs Guest 1337)",
    "TRUE BEAUTY (PRETTYPRINCESS vs 226w6)",
    "Fall of a Hero (SLASHER vs GUEST 1337)",
    "21ST CENTURY HUMOR (MLG Chance vs Hood Irony Whistle Occurrence)",
    "SHATTERED GRACE (GR1MX 1x1x1x1 vs. ANGEL SHEDLETSKY)",
    "----------- Scrapped LMS -----------",
    "THE DARKNESS IN YOUR HEART (Old 1x4 Vs Shedletsky)",
    "MEET YOUR MAKING (c00lkidd ~ 1x4 Vs 007n7 ~ Shedletsky)",
    "A Creation Of Sorrow (Hacklord vs The Heartbroken)",
    "Debth (Natrasha Vs Mafioso)",
    "ETERNAL HOPE, ETERNAL FIGHT (Old LMS)",
    "Receading Lifespan (Barber Jason Vs Bald Two Time)",
    "VIP Jason LMS (VIP Jason Vs All)",
    "Jason Hate This Song",
    "----------- Official LMS -----------",
    "A GRAVE SOUL (NOW, RUN) [All Killers Vs All Survivors]",
    "Plead (c00lkidd Vs 007n7)",
    "SMILE (Cupcakes Vs All)",
    "Vanity (Vanity Jason Vs All)",
    "Obsession (Gasharpoon Vs All)",
    "Burnout (Diva Vs Ghoul)",
    "Close To Me (Annihilation Vs Friend)",
    "Creation Of Hatred (1X4 Vs Shedletsky)",
    "Through Patches of Violet (Hacklord vs The Heartbroken)"
}
getgenv().tracks = {
    ["None"] = "",
    ["----------- UST -----------"] = "",
    ["A BRAVE SOUL (MS 4 Killer VS MS 4 Survivor)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/A%20BRAVE%20SOUL%20(MS%204%20Killer%20VS%20MS%204%20Survivor).mp3",
    ["BEGGED (MS 4 Coolkidd vs MS 4 007n7)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/BEGGED%20(MS%204%20Coolkidd%20vs%20MS%204%20007n7).mp3",
    ["DOOMSPIRE (HairyTwinkle VS Pedro.EXE)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/DOOMSPIRE%20-%20(HairyTwinkle%20VS%20Pedro.EXE).mp3",
    ["ECLIPSE (xX4ce0fSpadesXx vs dragondudes3)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/ECLIPSE%20(xX4ce0fSpadesXx%20vs%20dragondudes3).mp3",
    ["ERROR 264 (Noob Cosplay VS Yourself)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/ERROR%20264%20-%20(Noob%20Cosplay%20VS%20Yourself).mp3",
    ["GODS SECOND COMING (NOLI VS. 007n7)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/GODS%20SECOND%20COMING%20(NOLI%20VS.%20007n7).mp3",
    ["Entreat (Bluudude Vs 118o8)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Entreat%20(Bluudude%20Vs%20118o8).mp3",
    ["Implore (Comic vs Savior)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Implore%20(Comic%20vs%20Savior)%20-%20YouTube.mp3",
    ["Leftovers (Remix Vanity Jason Vs All)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Leftovers%20(Remix%20Vanity%20Jason%20Vs%20All).mp3",
    ["ORDER UP (Elliot VS c00lkidd)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/ORDER%20UP%20-%20(Elliot%20VS%20c00lkidd).mp3",
    ["PARADOX (Guest 666 Vs Guest 1337)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/PARADOX%20(Guest%20666%20Vs%20Guest%201337).mp3",
    ["TRUE BEAUTY (PRETTYPRINCESS vs 226w6)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/TRUE%20BEAUTY%20(PRETTYPRINCESS%20vs%20226w6).mp3",
    ["Fall of a Hero (SLASHER vs GUEST 1337)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/%5BSLASHER%20vs%20GUEST%201337%20-%20LAST%20MAN%20STANDING%5D%20Fall%20of%20a%20Hero%20-%20Forsaken%20UST.mp3",
    ["21ST CENTURY HUMOR (MLG Chance vs Hood Irony Whistle Occurrence)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/21ST%20CENTURY%20HUMOR%20-%20Last%20Man%20Standing%20(MLG%20Chance%20vs%20Hood%20Irony%20Whistle%20Occurrence)%20%20Forsaken%20UST.mp3",
    ["SHATTERED GRACE (GR1MX 1x1x1x1 vs. ANGEL SHEDLETSKY)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/SHATTERED%20GRACE%20%5BGR1MX%201x1x1x1%20vs.%20ANGEL%20SHEDLETSKY%20LAST%20MAN%20STANDING%5D%20(Roblox%20Forsaken%20UST).mp3",
    ["----------- Scrapped LMS -------Animations Copied

Name: Untitled
Animation Id: rbxassetid://14516273501--"] = "",
    ["THE DARKNESS IN YOUR HEART (Old 1x4 Vs Shedletsky)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/THE%20DARKNESS%20IN%20YOUR%20HEART%20(Old%201x4%20Vs%20Shedletsky).mp3",
    ["MEET YOUR MAKING (c00lkidd ~ 1x4 Vs 007n7 ~ Shedletsky)"] = "https:// github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/MEET%20YOUR%20MAKING%20(c00lkidd%20~%201x4%20Vs%20007n7%20~%20Shedletsky).mp3",
    ["A Creation Of Sorrow (Hacklord vs The Heartbroken)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/A%20Creation%20Of%20Sorrow%20(Hacklord%20vs%20The%20Heartbroken).mp3",
    ["Debth (Natrasha Vs Mafioso)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Debth%20(Natrasha%20Vs%20Mafioso).mp3",
    ["ETERNAL HOPE, ETERNAL FIGHT (Old LMS)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/ETERNAL%20HOPE,%20ETERNAL%20FIGHT%20(Old%20LMS).mp3",
    ["Receading Lifespan (Barber Jason Vs Bald Two Time)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Receading%20Lifespan%20(Barber%20Jason%20Vs%20Bald%20Two%20Time).mp3",
    ["VIP Jason LMS (VIP Jason Vs All)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/VIP%20Jason%20LMS%20(VIP%20Jason%20Vs%20All).mp3",
    ["Jason Hate This Song"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/California%20Gurls%20%20Audio%20Edit%20-%20Neonick.mp3",
    ["----------- Official LMS -----------"] = "",
    ["A GRAVE SOUL (NOW, RUN) [All Killers Vs All Survivors]"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/A%20GRAVE%20SOUL%20(NOW,%20RUN)%20%5BAll%20Killers%20Vs%20All%20Survivors%5D.mp3",
    ["Plead (c00lkidd Vs 007n7)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Plead%20(c00lkidd%20Vs%20007n7).mp3",
    ["SMILE (Cupcakes Vs All)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/SMILE%20(Cupcakes%20Vs%20All)%20.mp3",
    ["Vanity (Vanity Jason Vs All)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Vanity%20(Vanity%20Jason%20Vs%20All).mp3",
    ["Obsession (Gasharpoon Vs All)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Obsession%20(Gasharpoon%20Vs%20All).MP3",
    ["Burnout (Diva Vs Ghoul)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Burnout%20(Diva%20Vs%20Ghoul).mp3",
    ["Close To Me (Annihilation Vs Friend)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Close%20To%20Me%20(Annihilation%20Vs%20Friend).mp3",
    ["Creation Of Hatred (1X4 Vs Shedletsky)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Creation%20Of%20Hatred%20(1X4%20Vs%20Shedletsky).mp3",
    ["Through Patches of Violet (Hacklord vs The Heartbroken)"] = "https://github.com/NyansakenHub/NyansakenHub/raw/refs/heads/main/Through%20Patches%20of%20Violet%20(Hacklord%20vs%20The%20Heartbroken).mp3"
}
getgenv().currentLastSurvivor = nil
getgenv().currentSongId = nil
getgenv().originalSongId = nil
getgenv().isPlaying = false
getgenv().songStartTime = 0
getgenv().currentSongDuration = 0
getgenv().isToggleOn = false
getgenv().wasLastSurvivor = false
getgenv().toggleEnabled = false
getgenv().selectedSong = nil
getgenv().customSongUrl = nil
local function hashString(str)
    local sum = 0
    for i = 1, #str do
        sum = (sum + string.byte(str, i)) % 100000
    end
    return tostring(sum)
end
function downloadTrack(name, audioUrl)
    local safeName = name:gsub("[^%w]", "_")
    local uniqueSuffix = hashString(audioUrl)
    local fullPath = folderPath .. "/" .. safeName .. "_" .. uniqueSuffix .. ".mp3"
    if not isfile(fullPath) then
        local request = http_request or syn.request or request
        if not request then error("Executor does not support HTTP requests.") end
        local response = request({ Url = audioUrl, Method = "GET" })
        local fileData = response.Body or response.BodyRaw
        if fileData and #fileData > 0 then
            writefile(fullPath, fileData)
        end
    end
    return fullPath
end
function preloadAllTracks()
    for name, url in pairs(getgenv().tracks) do
        if url and url ~= "" then
            task.spawn(function()
                local success, err = pcall(function()
                    downloadTrack(name, url)
					task.wait(0.25)
                end)
            end)
        end
    end
end
preloadAllTracks()
function getLastSurvivor()
    local theme = workspace:FindFirstChild("Themes")
    if theme then
        return theme:FindFirstChild("LastSurvivor")
    end
    return nil
end
function checkChar(char)
    if not char or not char.Parent then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then
        local conn
        conn = RunService.Heartbeat:Connect(function()
            hrp = hrp or char:FindFirstChild("HumanoidRootPart")
            humanoid = humanoid or char:FindFirstChildOfClass("Humanoid")
            if hrp and humanoid then
                conn:Disconnect()
            end
        end)
    end
end
function setLastSurvivorSong(songKey)
    local lastSurvivor = getLastSurvivor()
    if not lastSurvivor then
        warn("[LMS] KhÃ´ng tÃ¬m tháº¥y LastSurvivor trong workspace.Themes")
        return
    end
    local url
    if songKey == "CustomURL" then
        url = getgenv().customSongUrl
    else
        url = getgenv().tracks[songKey]
    end
    if not url or url == "" then
        warn("[LMS] KhÃ´ng cÃ³ URL cho bÃ i: ", songKey)
        return
    end
    local path = downloadTrack(songKey, url)
    if not path or not isfile(path) then
        return
    end
    local success, soundAsset = pcall(function()
        return getcustomasset(path)
    end)
    if not success or not soundAsset then
        return
    end
    if getgenv().isToggleOn and not getgenv().originalSongId then
        getgenv().originalSongId = lastSurvivor.SoundId
    end
    lastSurvivor:Stop()
    lastSurvivor.SoundId = soundAsset
    task.spawn(function()
        if not lastSurvivor.IsLoaded then
            lastSurvivor.Loaded:Wait()
        end
        lastSurvivor:Play()
        getgenv().songStartTime = tick()
        getgenv().currentSongDuration = lastSurvivor.TimeLength
        getgenv().isPlaying = true
        getgenv().currentLastSurvivor = lastSurvivor
    end)
end
getgenv().RunService.Heartbeat:Connect(function()
    local lastSurvivor = getLastSurvivor()
    if getgenv().isToggleOn and not getgenv().isPlaying and lastSurvivor and getgenv().selectedSong then
        setLastSurvivorSong(getgenv().selectedSong)
    end
    if not lastSurvivor and getgenv().isPlaying then
        getgenv().isPlaying = false
    end
    if getgenv().isPlaying and getgenv().currentSongDuration > 0 then
        if tick() - getgenv().songStartTime >= getgenv().currentSongDuration then
            getgenv().isPlaying = false
        end
    end
    if not getgenv().toggleEnabled then return end
    if lastSurvivor and not getgenv().wasLastSurvivor then
        if LocalPlayer.Character then
            checkChar(LocalPlayer.Character)
        end
        getgenv().wasLastSurvivor = true
    elseif not lastSurvivor and getgenv().wasLastSurvivor then
        getgenv().wasLastSurvivor = false
    end
end)
getgenv().LocalPlayer.CharacterAdded:Connect(function(char)
    checkChar(char)
end)
Miscs:CreateSection("Last Man Standing")
Miscs:CreateToggle({
    Name = "LMS Replacer Song",
    CurrentValue = false,
    Flag = "LMS_Toggle",
    Callback = function(value)
        getgenv().isToggleOn = value
        local lastSurvivor = getLastSurvivor()
        if not value and lastSurvivor and getgenv().originalSongId then
            lastSurvivor.SoundId = getgenv().originalSongId
            lastSurvivor:Play()
            getgenv().originalSongId = nil
        end
    end
})
getgenv().DropdownLMS = Miscs:CreateDropdown({
    Name = "Custom LMS Song",
    Flag = "CustomLMSSong",
    Options = getgenv().orderedTrackKeys,
    MultipleOptions = false,
    Callback = function(selected)
        getgenv().customSongUrl = nil
        getgenv().selectedSong = type(selected) == "table" and selected[1] or selected
    end
})
Miscs:CreateInput({
    Name = "Custom LMS Song URL",
    Flag = "CustomLMSSongURL",
    PlaceholderText = "Raw Link MP3",
    Callback = function(input)
        if input and input ~= "" and input:match("^https?://") and input:lower():match("%.mp3$") then
            getgenv().customSongUrl = input
            getgenv().selectedSong = "CustomURL"
            local success, err = pcall(function()
                downloadTrack("CustomURL", input)
            end)
            if not success then
                return
            end
            local lastSurvivor = getLastSurvivor()
            if getgenv().isToggleOn and lastSurvivor then
                setLastSurvivorSong("CustomURL")
            end
        end
    end
})
Combat:CreateSection("Ability LMS")
Combat:CreateToggle({
    Name = "LMS Auto Ability (007n7, Two Time, Noob)",
    Flag = "LMSAutoToggle",
    CurrentValue = false,
    Callback = function(value)
        getgenv().toggleEnabled = value
    end
})
getgenv().TextChatService = game:GetService("TextChatService")
getgenv().chatEnabled = false
getgenv().connection = nil
Miscs:CreateSection("Chat")
Miscs:CreateToggle({
    Name = "Toggle Chat Visibility",
    CurrentValue = false,
    Flag = "ChatWindowToggle",
    Callback = function(value)
        getgenv().chatEnabled = value
        if getgenv().chatEnabled then
            getgenv().connection = RunService.Heartbeat:Connect(function()
                local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
				chatWindow.Enabled = true
            end)
        else
            if getgenv().connection then
                getgenv().connection:Disconnect()
                getgenv().connection = nil
            end
            local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
			chatWindow.Enabled = false
        end
    end
})
getgenv().PService = game:GetService("Players")
getgenv().RService = game:GetService("RunService")
getgenv().UIS = game:GetService("UserInputService")
getgenv().Me = PService.LocalPlayer
getgenv().MeGui = Me:WaitForChild("PlayerGui")
getgenv().ProtectToggle = false
local CoverList = {}
local HiddenUIList = {}
local function MaskText(obj)
    if obj:IsA("TextLabel") or obj:IsA("TextButton") then
        local function checkAndMask()
            if not getgenv().ProtectToggle then return end
            if not obj.Visible then
                if obj:FindFirstChild("CoverFrame") then
                    obj.CoverFrame:Destroy()
                end
                return
            end
            if obj:IsA("TextButton") and not obj.Active then
                if obj:FindFirstChild("CoverFrame") then
                    obj.CoverFrame:Destroy()
                end
                return
            end
            if obj.TextTransparency == 1 then
                if obj:FindFirstChild("CoverFrame") then
                    obj.CoverFrame:Destroy()
                end
                return
            end
            local parent = obj.Parent
            while parent and parent:IsA("GuiObject") do
                if not parent.Visible then
                    if obj:FindFirstChild("CoverFrame") then
                        obj.CoverFrame:Destroy()
                    end
                    return
                end
                parent = parent.Parent
            end
            local shouldMask = false
            for _, p in ipairs(PService:GetPlayers()) do
                local uname = string.lower(p.Name)
                local dname = string.lower(p.DisplayName)
                local txt = string.lower(obj.Text)
                if string.find(txt, uname) or string.find(txt, dname) then
                    shouldMask = true
                    break
                end
            end
            if shouldMask then
                if not obj:FindFirstChild("CoverFrame") then
                    local frame = Instance.new("Frame")
                    frame.Name = "CoverFrame"
                    frame.BackgroundColor3 = Color3.new(0, 0, 0)
                    frame.BorderSizePixel = 0
                    frame.Size = UDim2.new(1, 0, 1, 0)
                    frame.ZIndex = obj.ZIndex + 1
                    frame.Parent = obj
                    local label = Instance.new("TextLabel")
                    label.Name = "CoverText"
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Text = "Nyansaken Protection"
                    label.TextColor3 = Color3.new(1,1,1)
                    label.Font = Enum.Font.SourceSansBold
                    label.TextScaled = true
                    label.ZIndex = frame.ZIndex + 1
                    label.Parent = frame
                    table.insert(CoverList, frame)
                end
            else
                if obj:FindFirstChild("CoverFrame") then
                    obj.CoverFrame:Destroy()
                end
            end
        end
        obj:GetPropertyChangedSignal("Text"):Connect(checkAndMask)
        obj:GetPropertyChangedSignal("Visible"):Connect(checkAndMask)
        obj:GetPropertyChangedSignal("TextTransparency"):Connect(checkAndMask)
        if obj:IsA("TextButton") then
            obj:GetPropertyChangedSignal("Active"):Connect(checkAndMask)
        end
        checkAndMask()
    end
end
local function HideNametag(char)
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    end
end
local function ShowNametag(char)
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
    end
end
local function HookPlayer(plr)
    plr.CharacterAdded:Connect(function(char)
        char:WaitForChild("HumanoidRootPart")
        if getgenv().ProtectToggle then
            HideNametag(char)
        end
    end)
    if plr.Character then
        if getgenv().ProtectToggle then
            HideNametag(plr.Character)
        end
    end
end
local function HideIcon()
    if not getgenv().ProtectToggle then return end
    local tempUI = MeGui:FindFirstChild("TemporaryUI")
    if tempUI then
        local iconHolder = tempUI:FindFirstChild("PlayerIconHolder", true)
        if iconHolder and iconHolder:IsA("GuiObject") then
            if iconHolder.Visible then
                table.insert(HiddenUIList, iconHolder)
            end
            iconHolder.Visible = false
        end
    end
end
local function EnableProtect()
    for _, d in ipairs(MeGui:GetDescendants()) do
        MaskText(d)
    end
    MeGui.DescendantAdded:Connect(MaskText)
    for _, p in ipairs(PService:GetPlayers()) do
        HookPlayer(p)
        if p.Character then
            HideNametag(p.Character)
        end
    end
    PService.PlayerAdded:Connect(HookPlayer)
    RService.Heartbeat:Connect(HideIcon)
end
local function DisableProtect()
    for _, f in ipairs(CoverList) do
        if f and f.Parent then f:Destroy() end
    end
    CoverList = {}
    for _, ui in ipairs(HiddenUIList) do
        if ui and ui:IsA("GuiObject") then
            ui.Visible = true
        end
    end
    HiddenUIList = {}
    for _, p in ipairs(PService:GetPlayers()) do
        if p.Character then
            ShowNametag(p.Character)
        end
    end
end
Miscs:CreateSection("Protection")
Miscs:CreateToggle({
    Name = "Protection Name",
    CurrentValue = false,
    Flag = "ProtectionNameToggle",
    Callback = function(value)
        getgenv().ProtectToggle = value
        if getgenv().ProtectToggle then
            EnableProtect()
        else
            DisableProtect()
        end
    end
})
AchieveTab:CreateSection("Fun")
local function unlock(achieve)
   local remote = game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
   remote:FireServer("UnlockAchievement", { buffer.fromstring("\""..achieve.."\"") })
end
AchieveTab:CreateButton({
   Name = "[.] (Meet ogologl's best friend for the first time)",
    Flag = "Meetogologlsbestfriendforthefirsttime",
   Callback = function() unlock("MeetBrandon") end,
})
AchieveTab:CreateButton({
   Name = "[Meow meow meow] (Interact with the cat in the lobby more than 15 times)",
    Flag = "MeowmeowmeowInteractwiththecatinthelobbymorethan15times",
   Callback = function() unlock("ILoveCats") end,
})
AchieveTab:CreateButton({
   Name = "[Coming straight from YOUR house.] (??? - I Love TV)",
    Flag = "ComingstraightfromYOURhouseILoveTV",
   Callback = function() unlock("TVTIME") end,
})
AchieveTab:CreateButton({
   Name = "[A Captain and his Ship] (Hear his tale)",
    Flag = "ACaptainandhisShipHearhistale",
   Callback = function() unlock("MeetDemophon") end,
})
AchieveTab:CreateButton({
   Name = "[Black, White, and Gray.] (There is nothing either good or bad, but thinking makes it so...)",
    Flag = "BlackWhiteandGrayThereisnothingeithergoodorbadbutthinkingmakesitso",
   Callback = function() unlock("Morality") end,
})
local roundtime
local positionSet = false
local function adjustPosition()
    if roundtime and not positionSet then
        roundtime.Position = UDim2.new(
            roundtime.Position.X.Scale + 0.39,
            roundtime.Position.X.Offset,
            roundtime.Position.Y.Scale,
            roundtime.Position.Y.Offset
        )
        positionSet = true
    end
end
task.spawn(function()
    while not roundtime do
        roundtime = player:FindFirstChild("PlayerGui")
            and player.PlayerGui:FindFirstChild("RoundTimer")
            and player.PlayerGui.RoundTimer:FindFirstChild("Main")
        task.wait(0.1)
    end
    adjustPosition()
    while roundtime do
        roundtime.Position = UDim2.new(
            roundtime.Position.X.Scale,
            roundtime.Position.X.Offset,
            roundtime.Position.Y.Scale,
            roundtime.Position.Y.Offset
        )
        task.wait(0.5)
    end
end)
genv = {}
genv.running = false
genv.animTrack = nil
genv.toggleValue = false
function genv.getCharacterHumanoid()
    local character = game:GetService("Players").LocalPlayer.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    return character, humanoid
end
function genv.getAnimator(humanoid)
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end
    return animator
end
function genv.handleToggle(enabled)
    genv.running = enabled
    if not enabled and genv.animTrack then
        genv.animTrack:Stop()
        genv.animTrack = nil
    end
    local character, _ = genv.getCharacterHumanoid()
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        rootPart.Transparency = enabled and rootPart.Transparency or 1
    end
end
local survivorValue = playerData:WaitForChild("Equipped"):WaitForChild("Survivor")
function genv.updateToggle()
    local character, humanoid = genv.getCharacterHumanoid()
    local isTarget = (survivorValue.Value == "007n7" or survivorValue.Value == "Noob" or survivorValue.Value == "TwoTime") and humanoid and humanoid.MaxHealth < 300
    genv.handleToggle(isTarget)
end
Combat:CreateSection("Invisible Effect")
Combat:CreateToggle({
    Name = "Fully Invisible (Invisible Effect)",
    CurrentValue = false,
    Flag = "InvisibleToggle",
    Callback = function(Value)
        genv.toggleValue = Value
        if Value then
            genv.updateToggle()
        else
            genv.handleToggle(false)
        end
    end
})
survivorValue:GetPropertyChangedSignal("Value"):Connect(function()
    if genv.toggleValue then
        genv.updateToggle()
    end
end)
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.1)
    if genv.toggleValue then
        genv.updateToggle()
    end
end)
RunService.Heartbeat:Connect(function()
    if not genv.running then return end
    local character, humanoid = genv.getCharacterHumanoid()
    if not character or not humanoid then return end
    local animator = genv.getAnimator(humanoid)
    local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local status = game:GetService("Players").LocalPlayer.PlayerGui.MainUI.StatusContainer:FindFirstChild("Invisibility")
    if humanoid.MaxHealth < 300 and torso and torso.Transparency ~= 0 and status then
        if not genv.animTrack or not genv.animTrack.IsPlaying then
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://75804462760596"
            genv.animTrack = animator:LoadAnimation(animation)
            genv.animTrack.Looped = true
            genv.animTrack:Play(0)
            genv.animTrack:AdjustSpeed(0)
            genv.animTrack.TimePosition = 0
            if rootPart then
                rootPart.Transparency = 0.4
            end
        end
    else
        if genv.animTrack and genv.animTrack.IsPlaying then
            genv.animTrack:Stop(0)
            genv.animTrack = nil
            if rootPart then
                rootPart.Transparency = 1
            end
        end
    end
end)
local function getEmoteList()
    local list = {}
    for _, emote in ipairs(purchasedEmotesFolder:GetChildren()) do
        table.insert(list, emote.Name)
    end
    return list
end
local emoteList = getEmoteList()
local selectedEmote = emoteList[1]
local emoteGuiMain = Instance.new("ScreenGui")
emoteGuiMain.Name = "CustomEmoteGuiMain"
emoteGuiMain.ResetOnSpawn = false
emoteGuiMain.DisplayOrder = 999998
emoteGuiMain.Enabled = false
emoteGuiMain.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
local emoteGuiToggle = Instance.new("ScreenGui")
emoteGuiToggle.Name = "CustomEmoteGuiToggle"
emoteGuiToggle.ResetOnSpawn = false
emoteGuiToggle.DisplayOrder = 999999
emoteGuiToggle.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
local toggleEmoteGuiButton = Instance.new("ImageButton")
toggleEmoteGuiButton.Size = UDim2.new(0, 60, 0, 60)
toggleEmoteGuiButton.Position = UDim2.new(0.05, 340, 0.05, -47.5)
toggleEmoteGuiButton.AnchorPoint = Vector2.new(0.5, 0.5)
toggleEmoteGuiButton.BackgroundTransparency = 1
toggleEmoteGuiButton.Image = "rbxassetid://73335752800725"
toggleEmoteGuiButton.ZIndex = 999999
toggleEmoteGuiButton.Parent = emoteGuiToggle
local survivorValue = playerData:WaitForChild("Equipped"):WaitForChild("Survivor")
local guiVisible = false
local function updateToggle()
    local isTarget = survivorValue.Value == "007n7"
    emoteGuiToggle.Enabled = isTarget
    if not isTarget then
        emoteGuiMain.Enabled = false
        guiVisible = false
    end
end
updateToggle()
survivorValue:GetPropertyChangedSignal("Value"):Connect(updateToggle)
local playButton = Instance.new("TextButton")
playButton.Size = UDim2.new(0, 160, 0, 36)
playButton.Position = UDim2.new(1, -204, 0, 150)
playButton.BackgroundColor3 = Color3.fromRGB(80,80,80)
playButton.TextColor3 = Color3.new(1,1,1)
playButton.Font = Enum.Font.SourceSans
playButton.TextSize = 18
playButton.Text = "Boombox Clone (007n7)"
playButton.Parent = emoteGuiMain
local dropdownFrame = Instance.new("Frame")
dropdownFrame.Size = UDim2.new(0, 220, 0, 40)
dropdownFrame.Position = UDim2.new(1, -240, 0, 100)
dropdownFrame.BackgroundColor3 = Color3.fromRGB(40,40,40)
dropdownFrame.BorderSizePixel = 0
dropdownFrame.Parent = emoteGuiMain
local dropdownButton = Instance.new("TextButton")
dropdownButton.Size = UDim2.new(1,0,1,0)
dropdownButton.BackgroundColor3 = Color3.fromRGB(60,60,60)
dropdownButton.TextColor3 = Color3.new(1,1,1)
dropdownButton.Font = Enum.Font.SourceSans
dropdownButton.TextSize = 18
dropdownButton.Text = selectedEmote and ("Emote: "..selectedEmote) or "Choose Emote"
dropdownButton.Parent = dropdownFrame
local emoteListFrame = Instance.new("ScrollingFrame")
emoteListFrame.Size = UDim2.new(1,0,0, math.clamp(#emoteList,1,8) * 30)
emoteListFrame.Position = UDim2.new(0,0,1,2)
emoteListFrame.BackgroundColor3 = Color3.fromRGB(50,50,50)
emoteListFrame.BorderSizePixel = 0
emoteListFrame.Visible = false
emoteListFrame.CanvasSize = UDim2.new(0,0,0, #emoteList * 30)
emoteListFrame.ScrollBarThickness = 6
emoteListFrame.Parent = dropdownFrame
local listLayout = Instance.new("UIListLayout")
listLayout.FillDirection = Enum.FillDirection.Vertical
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Parent = emoteListFrame
local function populateDropdown(list)
    for _, child in ipairs(emoteListFrame:GetChildren()) do
        if child:IsA("TextButton") then child:Destroy() end
    end
    for _, name in ipairs(list) do
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(1, -6, 0, 30)
        btn.Position = UDim2.new(0, 3, 0, 0)
        btn.BackgroundColor3 = Color3.fromRGB(70,70,70)
        btn.TextColor3 = Color3.new(1,1,1)
        btn.Font = Enum.Font.SourceSans
        btn.TextSize = 16
        btn.Text = name
        btn.Parent = emoteListFrame
        btn.MouseButton1Click:Connect(function()
            selectedEmote = name
            dropdownButton.Text = "Emote: " .. name
            emoteListFrame.Visible = false
        end)
    end
    emoteListFrame.CanvasSize = UDim2.new(0,0,0, #list * 30)
    emoteListFrame.Size = UDim2.new(1,0,0, math.clamp(#list,1,8) * 30)
end
populateDropdown(emoteList)
dropdownButton.MouseButton1Click:Connect(function()
    emoteListFrame.Visible = not emoteListFrame.Visible
    if emoteListFrame.Visible then
		RemoteEvent:FireServer("StopEmote", {
        buffer.fromstring("\"Animations\""),
        buffer.fromstring("\""..selectedEmote.."\"")
    })
    end
end)
local emotesFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Emotes")
local network = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local emotesValue = player.PlayerData.Equipped.Emotes.Value
local firstEmote
playButton.MouseButton1Click:Connect(function()
    if not selectedEmote then return end
for emote in string.gmatch(emotesValue, "[^|]+") do
    firstEmote = emote
    break
end
if not firstEmote or firstEmote == "nil" then
    firstEmote = "noemotes"
end
if firstEmote then
    network:FireServer("EquipState", {emotesFolder:WaitForChild(selectedEmote), buffer.fromstring("1")})
    network:FireServer("PlayEmote", {
        buffer.fromstring("\"Animations\""),
        buffer.fromstring("\""..selectedEmote.."\"")
    })
    task.wait(0.1)
    network:FireServer("StopEmote", {
        buffer.fromstring("\"Animations\""),
        buffer.fromstring("\""..selectedEmote.."\"")
    })
    if firstEmote ~= "noemotes" then
	    network:FireServer("EquipState", {emotesFolder:WaitForChild(firstEmote), buffer.fromstring("1")})
    else
        network:FireServer("EquipState", { buffer.fromstring("\"Emotes\""), 1 })
    end
    task.wait(0.1)
    network:FireServer("UseActorAbility", { buffer.fromstring("\"Clone\"") })
    emoteListFrame.Visible = false
else
    warn("KhÃ´ng tÃ¬m tháº¥y emote há»£p lá»‡ Ä‘á»ƒ sá»­ dá»¥ng.")
end
end)
toggleEmoteGuiButton.MouseButton1Click:Connect(function()
    guiVisible = not guiVisible
    emoteGuiMain.Enabled = guiVisible
    if not guiVisible then
        emoteListFrame.Visible = false
    end
end)
local emotes2 = getEmoteList()
local screenGui2 = Instance.new("ScreenGui")
screenGui2.DisplayOrder = 999999
screenGui2.Name = "EmoteGUI2"
screenGui2.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
screenGui2.ResetOnSpawn = false
screenGui2.ZIndexBehavior = Enum.ZIndexBehavior.Global
local background2 = Instance.new("Frame")
background2.Size = UDim2.new(0, 260, 0, 100)
background2.Position = UDim2.new(0, 0, 0.203, 0)
background2.BackgroundTransparency = 1
background2.BorderSizePixel = 0
background2.Visible = false
background2.Parent = screenGui2
local playButton2 = Instance.new("TextButton")
playButton2.Size = UDim2.new(0, 160, 0, 36)
playButton2.Position = UDim2.new(0, 50, 0, 60)
playButton2.BackgroundColor3 = Color3.fromRGB(80,80,80)
playButton2.TextColor3 = Color3.new(1,1,1)
playButton2.Font = Enum.Font.SourceSans
playButton2.TextSize = 18
playButton2.Text = "Play Emote"
playButton2.Parent = background2
local dropdownFrame2 = Instance.new("Frame")
dropdownFrame2.Size = UDim2.new(0, 220, 0, 40)
dropdownFrame2.Position = UDim2.new(0, 20, 0, 10)
dropdownFrame2.BackgroundColor3 = Color3.fromRGB(40,40,40)
dropdownFrame2.BorderSizePixel = 0
dropdownFrame2.Parent = background2
local dropdownButton2 = Instance.new("TextButton")
dropdownButton2.Size = UDim2.new(1,0,1,0)
dropdownButton2.BackgroundColor3 = Color3.fromRGB(60,60,60)
dropdownButton2.TextColor3 = Color3.new(1,1,1)
dropdownButton2.Font = Enum.Font.SourceSans
dropdownButton2.TextSize = 18
dropdownButton2.Text = emotes2[1] and ("Emote: "..emotes2[1]) or "Choose Emote"
dropdownButton2.Parent = dropdownFrame2
local emoteListFrame2 = Instance.new("ScrollingFrame")
emoteListFrame2.Size = UDim2.new(1,0,0, math.clamp(#emotes2,1,8) * 30)
emoteListFrame2.Position = UDim2.new(0,0,1,2)
emoteListFrame2.BackgroundColor3 = Color3.fromRGB(50,50,50)
emoteListFrame2.BorderSizePixel = 0
emoteListFrame2.Visible = false
emoteListFrame2.CanvasSize = UDim2.new(0,0,0, #emotes2 * 30)
emoteListFrame2.ScrollBarThickness = 6
emoteListFrame2.Parent = dropdownFrame2
local listLayout2 = Instance.new("UIListLayout")
listLayout2.FillDirection = Enum.FillDirection.Vertical
listLayout2.SortOrder = Enum.SortOrder.LayoutOrder
listLayout2.Parent = emoteListFrame2
local selectedEmote2 = emotes2[1]
local function populateDropdown2(list)
	for _, child in ipairs(emoteListFrame2:GetChildren()) do
		if child:IsA("TextButton") then child:Destroy() end
	end
	for _, name in ipairs(list) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(1, -6, 0, 30)
		btn.Position = UDim2.new(0, 3, 0, 0)
		btn.BackgroundColor3 = Color3.fromRGB(70,70,70)
		btn.TextColor3 = Color3.new(1,1,1)
		btn.Font = Enum.Font.SourceSans
		btn.TextSize = 16
		btn.Text = name
		btn.Parent = emoteListFrame2
		btn.MouseButton1Click:Connect(function()
			selectedEmote2 = name
			dropdownButton2.Text = "Emote: " .. name
			emoteListFrame2.Visible = false
		end)
	end
	emoteListFrame2.CanvasSize = UDim2.new(0,0,0, #list * 30)
	emoteListFrame2.Size = UDim2.new(1,0,0, math.clamp(#list,1,8) * 30)
end
populateDropdown2(emotes2)
dropdownButton2.MouseButton1Click:Connect(function()
	emoteListFrame2.Visible = not emoteListFrame2.Visible
	if emoteListFrame2.Visible then
		RemoteEvent:FireServer("StopEmote", {
        buffer.fromstring("\"Animations\""),
        buffer.fromstring("\""..selectedEmote.."\"")
    })
	end
end)
local emotesFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Emotes")
local network = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local emotesValue = player.PlayerData.Equipped.Emotes.Value
local firstEmote
playButton2.MouseButton1Click:Connect(function()
    if not selectedEmote2 then return end
for emote in string.gmatch(emotesValue, "[^|]+") do
    firstEmote = emote
    break
end
if not firstEmote or firstEmote == "nil" then
    firstEmote = "noemotes"
end
if firstEmote then
    network:FireServer("EquipState", {emotesFolder:WaitForChild(selectedEmote2), buffer.fromstring("1")})
    network:FireServer("PlayEmote", {
        buffer.fromstring("\"Animations\""),
        buffer.fromstring("\""..selectedEmote2.."\"")
    })
    if firstEmote ~= "noemotes" then
    network:FireServer("EquipState", {emotesFolder:WaitForChild(selectedEmote2), buffer.fromstring("1")})
    else
        network:FireServer("EquipState", {
            buffer.fromstring("\"Emotes\""),
            buffer.fromstring("1")
        })
    end
else
    warn("KhÃ´ng tÃ¬m tháº¥y emote há»£p lá»‡ Ä‘á»ƒ sá»­ dá»¥ng.")
end
end)
local toggleButton2 = Instance.new("ImageButton")
toggleButton2.Size = UDim2.new(0, 60, 0, 60)
toggleButton2.Position = UDim2.new(0.05, 248, 0.05, -47.5)
toggleButton2.AnchorPoint = Vector2.new(0.5, 0.5)
toggleButton2.BackgroundTransparency = 1
toggleButton2.Image = "rbxassetid://87214736647237"
toggleButton2.Parent = screenGui2
toggleButton2.ZIndex = 200010
toggleButton2.MouseButton1Click:Connect(function()
	background2.Visible = not background2.Visible
	if background2.Visible then
		RemoteEvent:FireServer("StopEmote", {
        buffer.fromstring("\"Animations\""),
        buffer.fromstring("\""..selectedEmote.."\"")
    })
	end
end)
local function refreshAll()
	local newList = getEmoteList()
	emoteList = newList
	populateDropdown(newList)
	populateDropdown2(newList)
	if #newList > 0 then
		selectedEmote = selectedEmote or newList[F1]
		selectedEmote2 = selectedEmote2 or newList[1]
		dropdownButton.Text = "Emote: " .. selectedEmote
		dropdownButton2.Text = "Emote: " .. selectedEmote2
	else
		selectedEmote = nil
		selectedEmote2 = nil
		dropdownButton.Text = "Choose Emote"
		dropdownButton2.Text = "Choose Emote"
	end
end
purchasedEmotesFolder.ChildAdded:Connect(refreshAll)
purchasedEmotesFolder.ChildRemoved:Connect(refreshAll)
Rayfield:LoadConfiguration()
