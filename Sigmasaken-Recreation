-- ESP por modelo (único highlight + billboard por modelo)
-- Script OPTIMIZADO para rendimiento

-- Servicios
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local Players = game.Players
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local sk8module = require(game:GetService("ReplicatedStorage").Assets.Survivors.Veeronica.Config)
local nolimodule = require(game:GetService("ReplicatedStorage").Assets.Killers.Noli.Config)

-- Rayfield (UI) loader (mantén tu URL)
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Tables / estados
local espConfig = {
    enabled = false,
    billboardEnabled = false,
    transparency = 0.5,
    refillTransparency = 0.75,
    minionEnabled = false,
    ritualEnabled = false,
    footprintEnabled = false,
    colors = {}
}

local defaultColors = {
    killer = { highlight = Color3.fromRGB(255,100,100), fill = Color3.fromRGB(255,200,200) },
    survivor = { highlight = Color3.fromRGB(100,255,100), fill = Color3.fromRGB(200,255,200) },
    fakeGenerator = { highlight = Color3.fromRGB(255,100,100), fill = Color3.fromRGB(255,150,150) },
    generator = { highlight = Color3.fromRGB(100,150,255), fill = Color3.fromRGB(150,200,255) },
    minion = { highlight = Color3.fromRGB(0,150,0), fill = Color3.fromRGB(50,200,50) },
    shadow = { highlight = Color3.fromRGB(255,100,100), fill = Color3.fromRGB(255,150,150) },
    ritual = { highlight = Color3.fromRGB(150,150,150), fill = Color3.fromRGB(255,255,255) }
}

espConfig.colors = table.clone(defaultColors)

-- Storage optimizado
local modelHighlights = {}   -- [model] = Highlight
local modelBillboards = {}   -- [model] = BillboardGui
local processedModels = {}   -- [model] = true
local espConnections = {}    -- guardamos conexiones para desconectar luego

-- Cache de búsquedas frecuentes
local workspaceCache = {}
local function getCachedChild(parent, name)
    if not parent then return nil end
    local key = parent:GetFullName() .. "_" .. name
    if workspaceCache[key] == nil then
        workspaceCache[key] = parent:FindFirstChild(name)
    end
    return workspaceCache[key]
end

-- Limpieza optimizada
local function cleanupESP()
    -- Destruir highlights
    for model, h in pairs(modelHighlights) do
        if h then
            task.spawn(function()
                pcall(h.Destroy, h)
            end)
        end
    end
    table.clear(modelHighlights)
    
    -- Destruir billboards
    for model, b in pairs(modelBillboards) do
        if b then
            task.spawn(function()
                pcall(b.Destroy, b)
            end)
        end
    end
    table.clear(modelBillboards)
    
    -- Desconectar conexiones
    for _, conn in pairs(espConnections) do
        if conn then
            pcall(conn.Disconnect, conn)
        end
    end
    table.clear(espConnections)
    
    table.clear(processedModels)
    table.clear(workspaceCache)
end

-- Helpers: consigue una parte válida para adornear (PrimaryPart preferida)
local function getAdorneePartForModel(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end

    -- Buscar una parte que sea BasePart
    for _, c in ipairs(model:GetChildren()) do
        if c:IsA("BasePart") then
            return c
        end
    end

    return nil
end

-- Aplica highlight y billboard a UN modelo (no partes) - OPTIMIZADO
local function applyModelESP(model, colorConfig, objectType)
    if not model or typeof(model) ~= "Instance" then return end
    
    -- Verificar si el modelo sigue existiendo
    if not model.Parent then
        if modelHighlights[model] then
            pcall(modelHighlights[model].Destroy, modelHighlights[model])
            modelHighlights[model] = nil
        end
        if modelBillboards[model] then
            pcall(modelBillboards[model].Destroy, modelBillboards[model])
            modelBillboards[model] = nil
        end
        processedModels[model] = nil
        return
    end
    
    if processedModels[model] then
        -- si ya fue procesado, aseguramos que el highlight/billboard existan y actualizamos valores
        local existingHighlight = modelHighlights[model]
        if existingHighlight and existingHighlight.Parent then
            existingHighlight.FillTransparency = espConfig.refillTransparency
            existingHighlight.OutlineTransparency = espConfig.transparency
            existingHighlight.FillColor = colorConfig.fill
            existingHighlight.OutlineColor = colorConfig.highlight
        end

        local existingBill = modelBillboards[model]
        if existingBill and existingBill.Parent then
            local label = existingBill:FindFirstChildWhichIsA("TextLabel", true)
            if label then
                label.Text = objectType
                label.TextColor3 = colorConfig.highlight
            end
            existingBill.Enabled = espConfig.billboardEnabled
        end

        return
    end

    local adornPart = getAdorneePartForModel(model)
    if not adornPart then
    return
end
    -- Crear Highlight
    local ok, highlight = pcall(function()
        local h = Instance.new("Highlight")
        h.Name = "ESP_Highlight_" .. (objectType or "Object")
        h.Adornee = model -- Highlight acepta Model o BasePart
        h.Parent = CoreGui
        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        h.FillTransparency = espConfig.refillTransparency
        h.OutlineTransparency = espConfig.transparency
        h.FillColor = colorConfig.fill
        h.OutlineColor = colorConfig.highlight
        return h
    end)

    if ok and highlight then
        modelHighlights[model] = highlight
    end

    -- Crear Billboard por modelo (anclar al adornPart). Solo 1 por modelo.
    if espConfig.billboardEnabled then
        local success, billboard = pcall(function()
            local b = Instance.new("BillboardGui")
            b.Name = "ESP_Billboard_" .. (objectType or "Object")
            b.Adornee = adornPart
            b.Size = UDim2.new(0, 200, 0, 40)
            b.StudsOffset = Vector3.new(0, 3, 0)
            b.AlwaysOnTop = true
            b.Parent = CoreGui
            b.Enabled = true

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Text = objectType
            label.TextColor3 = colorConfig.highlight
            label.TextSize = 14
            label.Font = Enum.Font.GothamBold
            label.Parent = b

            return b
        end)

        if success and billboard then
            modelBillboards[model] = billboard
        end
    end

    -- Marca como procesado
    processedModels[model] = true
end

-- Buscadores OPTIMIZADOS (sin escaneos completos de workspace)
local function findKillersAndSurvivors()
    local killers = {}
    local survivors = {}

    local playersFolder = getCachedChild(Workspace, "Players")
    if playersFolder then
        local killersFolder = getCachedChild(playersFolder, "Killers")
        if killersFolder then
            for _, k in ipairs(killersFolder:GetChildren()) do
                if k:IsA("Model") then table.insert(killers, k) end
            end
        end

        local survivorsFolder = getCachedChild(playersFolder, "Survivors")
        if survivorsFolder then
            for _, s in ipairs(survivorsFolder:GetChildren()) do
                if s:IsA("Model") then table.insert(survivors, s) end
            end
        end
    end

    return killers, survivors
end

local function findGenerators()
    local generators = {}
    local fakeGenerators = {}

    local map = getCachedChild(Workspace, "Map")
    if not map then return generators, fakeGenerators end

    local ingame = getCachedChild(map, "Ingame")
    if not ingame then return generators, fakeGenerators end

    -- scan ingame
    for _, obj in ipairs(ingame:GetChildren()) do
        if obj.Name == "Generator" and obj:IsA("Model") then
            table.insert(generators, obj)
        elseif obj.Name == "FakeGenerator" and obj:IsA("Model") then
            table.insert(fakeGenerators, obj)
        end
    end

    -- check for nested Map inside ingame and scan that too
    local nestedMap = ingame:FindFirstChild("Map")
    if nestedMap then
        for _, obj in ipairs(nestedMap:GetChildren()) do
            if obj.Name == "Generator" and obj:IsA("Model") then
                table.insert(generators, obj)
            elseif obj.Name == "FakeGenerator" and obj:IsA("Model") then
                table.insert(fakeGenerators, obj)
            end
        end
    end

    return generators, fakeGenerators
end

-- Sistema de eventos para Shadow Parts (NO escaneos completos)
local shadowParts = {}

local function setupShadowDetection()
    local map = Workspace:FindFirstChild("Map")
    if not map then return end

    local ingame = map:FindFirstChild("Ingame")
    if not ingame then return end

    local nestedMap = ingame:FindFirstChild("Map")

    -- If nested Map isn’t there yet, wait for it safely
    if not nestedMap then
        ingame.ChildAdded:Connect(function(child)
            if child.Name == "Map" then
                nestedMap = child
            end
        end)
        -- Stop here until nestedMap appears
        repeat task.wait() until nestedMap
    end

    -- Initial scan
    for _, obj in ipairs(nestedMap:GetDescendants()) do
        if obj.Name:lower():match("shadow") then
            shadowParts[obj] = true
        end
    end

    -- EVENTS ONLY ON THE NESTED MAP
    local addedConn = nestedMap.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("BasePart") and descendant.Name:lower():match("hadow") then
            shadowParts[descendant] = true
        end
    end)

    local removedConn = nestedMap.DescendantRemoving:Connect(function(descendant)
        if shadowParts[descendant] then
            shadowParts[descendant] = nil
        end
    end)

    table.insert(espConnections, addedConn)
    table.insert(espConnections, removedConn)
end


-- Sistema similar para Minions
local minionModels = {}
local function setupMinionDetection()
    local function initialMinionScan()
        for _, obj in ipairs(Workspace.Map:GetDescendants()) do
            if obj:IsA("Model") then
                local nameLower = obj.Name:lower()
                if nameLower:match("minion") or nameLower:match("zombie") then
                    minionModels[obj] = true
                end
            end
        end
    end
    
    task.spawn(initialMinionScan)
    
    local minionAdded = Workspace.Map.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") then
            local nameLower = descendant.Name:lower()
            if nameLower:match("minion") or nameLower:match("zombie") then
                minionModels[descendant] = true
                if espConfig.enabled and espConfig.minionEnabled then
                    task.defer(function()
                        applyModelESP(descendant, espConfig.colors.minion, "Minion")
                    end)
                end
            end
        end
    end)
    
    local minionRemoved = Workspace.DescendantRemoving:Connect(function(descendant)
        if minionModels[descendant] then
            minionModels[descendant] = nil
            local highlight = modelHighlights[descendant]
            if highlight then
                pcall(highlight.Destroy, highlight)
                modelHighlights[descendant] = nil
            end
        end
    end)
    
    table.insert(espConnections, minionAdded)
    table.insert(espConnections, minionRemoved)
end

-- Sistema para Rituals
local ritualParts = {}
local function setupRitualDetection()
    local function initialRitualScan()
        for _, obj in ipairs(Workspace.Map:GetDescendants()) do
            if obj.Name:match("RespawnLocation") then
                ritualParts[obj] = true
            end
        end
    end
    
    task.spawn(initialRitualScan)
    
    local ritualAdded = Workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("BasePart") and descendant.Name:match("RespawnLocation") then
            ritualParts[descendant] = true
            if espConfig.enabled and espConfig.ritualEnabled then
                task.defer(function()
                    if not modelHighlights[descendant] then
                        local ok, highlight = pcall(function()
                            local h = Instance.new("Highlight")
                            h.Name = "ESP_Highlight_Ritual"
                            h.Adornee = descendant
                            h.Parent = CoreGui
                            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                            h.FillTransparency = espConfig.refillTransparency
                            h.OutlineTransparency = espConfig.transparency
                            h.FillColor = espConfig.colors.ritual.fill
                            h.OutlineColor = espConfig.colors.ritual.highlight
                            return h
                        end)
                        if ok and highlight then
                            modelHighlights[descendant] = highlight
                        end
                    end
                end)
            end
        end
    end)
    
    local ritualRemoved = Workspace.DescendantRemoving:Connect(function(descendant)
        if ritualParts[descendant] then
            ritualParts[descendant] = nil
            local highlight = modelHighlights[descendant]
            if highlight then
                pcall(highlight.Destroy, highlight)
                modelHighlights[descendant] = nil
            end
        end
    end)
    
    table.insert(espConnections, ritualAdded)
    table.insert(espConnections, ritualRemoved)
end

-- Función principal de actualización OPTIMIZADA
local updating = false
local lastUpdateTime = 0
local updateCooldown = 10 -- 10 segundos entre actualizaciones completas (en lugar de 3)

local function updateESP()
    if tick() - lastUpdateTime < updateCooldown then
    updating = false
    return
end

    if not espConfig.enabled then
        cleanupESP()
        updating = false
        return
    end

    -- Actualizar configuraciones existentes primero (rápido)
    for model, highlight in pairs(modelHighlights) do
        if highlight and highlight.Parent then
            highlight.FillTransparency = espConfig.refillTransparency
            highlight.OutlineTransparency = espConfig.transparency
        end
    end

    -- Killers & Survivors
    local killers, survivors = findKillersAndSurvivors()
    for _, k in ipairs(killers) do
        applyModelESP(k, espConfig.colors.killer, "Killer")
    end
    for _, s in ipairs(survivors) do
        applyModelESP(s, espConfig.colors.survivor, "Survivor")
    end

    -- Generators
    local gens, fakeGens = findGenerators()
    for _, g in ipairs(gens) do
        applyModelESP(g, espConfig.colors.generator, "Generator")
    end
    for _, fg in ipairs(fakeGens) do
        applyModelESP(fg, espConfig.colors.fakeGenerator, "FakeGenerator")
    end

    -- Shadow Parts (ya están en caché)
    if espConfig.enabled then
        for part in pairs(shadowParts) do
            if part.Parent and not modelHighlights[part] then
                local ok, highlight = pcall(function()
                    local h = Instance.new("Highlight")
                    h.Name = "ESP_Highlight_Shadow"
                    h.Adornee = part
                    h.Parent = CoreGui
                    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    h.FillTransparency = espConfig.refillTransparency
                    h.OutlineTransparency = espConfig.transparency
                    h.FillColor = espConfig.colors.shadow.fill
                    h.OutlineColor = espConfig.colors.shadow.highlight
                    return h
                end)
                if ok and highlight then
                    modelHighlights[part] = highlight
                end
            end
        end
    end

    -- Minions (si están habilitados)
    if espConfig.minionEnabled then
        for model in pairs(minionModels) do
            if model.Parent then
                applyModelESP(model, espConfig.colors.minion, "Minion")
            end
        end
    end

    -- Rituals (si están habilitados)
    if espConfig.ritualEnabled then
        for part in pairs(ritualParts) do
            if part.Parent and not modelHighlights[part] then
                local ok, highlight = pcall(function()
                    local h = Instance.new("Highlight")
                    h.Name = "ESP_Highlight_Ritual"
                    h.Adornee = part
                    h.Parent = CoreGui
                    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    h.FillTransparency = espConfig.refillTransparency
                    h.OutlineTransparency = espConfig.transparency
                    h.FillColor = espConfig.colors.ritual.fill
                    h.OutlineColor = espConfig.colors.ritual.highlight
                    return h
                end)
                if ok and highlight then
                    modelHighlights[part] = highlight
                end
            end
        end
    end

    -- Limpiar objetos que ya no existen
    for model, highlight in pairs(modelHighlights) do
        if not highlight.Parent or (model.Parent == nil) then
            pcall(highlight.Destroy, highlight)
            modelHighlights[model] = nil
            processedModels[model] = nil
        end
    end
    
    for model, billboard in pairs(modelBillboards) do
        if not billboard.Parent or (model.Parent == nil) then
            pcall(billboard.Destroy, billboard)
            modelBillboards[model] = nil
        end
    end

    updating = false
    lastUpdateTime = tick()
end

-- Setup UI con Rayfield (tu configuración original, adaptada a este script)
local Window = Rayfield:CreateWindow({
   Name = "Sigmasaken RE-Made",
   Icon = 0,
   LoadingTitle = "Made By: FaZ",
   LoadingSubtitle = "Sigmasaken but more features",
   Theme = "Default",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil,
      FileName = "Sigma-Sakened"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink",
      RememberJoins = true
   },
   KeySystem = false
})

local Tab = Window:CreateTab("ESP", 4483362458)

-- Main Toggle
local espthing = Tab:CreateToggle({
   Name = "Enable ESP",
   CurrentValue = false,
   Callback = function(Value)
       espConfig.enabled = Value
       if not Value then
           cleanupESP()
       else
           updateESP()
       end
   end,
})

-- Billboard Toggle
local espbillthing = Tab:CreateToggle({
   Name = "Enable Billboard ESP",
   CurrentValue = false,
   Callback = function(Value)
       espConfig.billboardEnabled = Value

       -- actualizar billboards existentes (habilitar/deshabilitar)
       for model, billboard in pairs(modelBillboards) do
           if billboard and billboard.Parent then
               billboard.Enabled = Value
           end
       end

       if Value and espConfig.enabled then
           updateESP()
       end
   end,
})

-- Sliders
local esptransparency = Tab:CreateSlider({
   Name = "ESP Outline Transparency",
   Range = {0, 1},
   Increment = 0.05,
   Suffix = "Transparency",
   CurrentValue = espConfig.transparency,
   Callback = function(Value)
       espConfig.transparency = Value
       for _, highlight in pairs(modelHighlights) do
           if highlight and highlight.Parent then
               highlight.OutlineTransparency = Value
           end
       end
   end,
})

local esprefilltransparency = Tab:CreateSlider({
   Name = "ESP Fill Transparency",
   Range = {0, 1},
   Increment = 0.05,
   Suffix = "Transparency",
   CurrentValue = espConfig.refillTransparency,
   Callback = function(Value)
       espConfig.refillTransparency = Value
       for _, highlight in pairs(modelHighlights) do
           if highlight and highlight.Parent then
               highlight.FillTransparency = Value
           end
       end
   end,
})

local Section = Tab:CreateSection("ESP Editor")

local espminion = Tab:CreateToggle({
   Name = "Enable Minion/Zombie ESP",
   CurrentValue = false,
   Callback = function(Value)
       espConfig.minionEnabled = Value
       if espConfig.enabled then updateESP() end
   end,
})

local espritual = Tab:CreateToggle({
   Name = "Enable Ritual ESP",
   CurrentValue = false,
   Callback = function(Value)
       espConfig.ritualEnabled = Value
       if espConfig.enabled then updateESP() end
   end,
})

local espfootprint = Tab:CreateToggle({
   Name = "Enable Digital Footprint ESP",
   CurrentValue = false,
   Callback = function(Value)
       espConfig.footprintEnabled = Value
       if espConfig.enabled then updateESP() end
   end,
})

-- Color pickers (solo highlight color, keep fill colors default or change if you want)
Tab:CreateColorPicker({
    Name = "Killer Color",
    Color = defaultColors.killer.highlight,
    Flag = "KillerColor",
    Callback = function(Value)
        espConfig.colors.killer.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Tab:CreateColorPicker({
    Name = "Survivor Color",
    Color = defaultColors.survivor.highlight,
    Flag = "SurvivorColor",
    Callback = function(Value)
        espConfig.colors.survivor.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Tab:CreateColorPicker({
    Name = "Fake Generator Color",
    Color = defaultColors.fakeGenerator.highlight,
    Flag = "FakeGeneratorColor",
    Callback = function(Value)
        espConfig.colors.fakeGenerator.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Tab:CreateColorPicker({
    Name = "Generator Color",
    Color = defaultColors.generator.highlight,
    Flag = "GeneratorColor",
    Callback = function(Value)
        espConfig.colors.generator.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Tab:CreateColorPicker({
    Name = "Minion Color",
    Color = defaultColors.minion.highlight,
    Flag = "MinionColor",
    Callback = function(Value)
        espConfig.colors.minion.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Tab:CreateColorPicker({
    Name = "Shadow Color",
    Color = defaultColors.shadow.highlight,
    Flag = "ShadowColor",
    Callback = function(Value)
        espConfig.colors.shadow.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Tab:CreateColorPicker({
    Name = "Ritual Color",
    Color = defaultColors.ritual.highlight,
    Flag = "RitualColor",
    Callback = function(Value)
        espConfig.colors.ritual.highlight = Value
        if espConfig.enabled then updateESP() end
    end
})

Rayfield:LoadConfiguration()

-- Detección dinámica OPTIMIZADA
local function setupDynamicDetection()
    setupShadowDetection()
    setupMinionDetection()
    setupRitualDetection()
    
    -- Players folders
    local playersFolder = getCachedChild(Workspace, "Players")
    if playersFolder then
        local killersFolder = getCachedChild(playersFolder, "Killers")
        if killersFolder then
            local conn = killersFolder.ChildAdded:Connect(function(child)
                if espConfig.enabled and child:IsA("Model") then
                    task.wait(0.4)
                    applyModelESP(child, espConfig.colors.killer, "Killer")
                end
            end)
            table.insert(espConnections, conn)
        end

        local survivorsFolder = getCachedChild(playersFolder, "Survivors")
        if survivorsFolder then
            local conn = survivorsFolder.ChildAdded:Connect(function(child)
                if espConfig.enabled and child:IsA("Model") then
                    task.wait(0.4)
                    applyModelESP(child, espConfig.colors.survivor, "Survivor")
                end
            end)
            table.insert(espConnections, conn)
        end
    end

    -- Map.Ingame children
    local map = getCachedChild(Workspace, "Map")
    if map then
        local ingame = getCachedChild(map, "Ingame")
        if ingame then
            local conn = ingame.ChildAdded:Connect(function(child)
                if not espConfig.enabled then return end
                task.wait(0.3)
                if child.Name == "Generator" and child:IsA("Model") then
                    applyModelESP(child, espConfig.colors.generator, "Generator")
                elseif child.Name == "FakeGenerator" and child:IsA("Model") then
                    applyModelESP(child, espConfig.colors.fakeGenerator, "FakeGenerator")
                elseif child:IsA("Model") and espConfig.minionEnabled then
                    local lname = child.Name:lower()
                    if lname:find("minion") or lname:find("zombie") then
                        applyModelESP(child, espConfig.colors.minion, "Minion")
                    end
                end
            end)
            table.insert(espConnections, conn)
        end
    end
end

-- Heartbeat optimizado (solo limpieza periódica)
RunService.Heartbeat:Connect(function(deltaTime)
    if not espConfig.enabled then return end
    
    -- Actualización periódica muy lenta (10 segundos)
    if tick() - lastUpdateTime >= updateCooldown then
        task.spawn(updateESP)
    end
end)

-- Inicialización
task.spawn(function()
    task.wait(2) -- Esperar a que el juego cargue
    setupDynamicDetection()
    if espConfig.enabled then 
        updateESP() 
    end
end)

-- Función para limpiar cuando se deshabilita el script
local function onExit()
    cleanupESP()
end

-------------------------------------------------------------------
local StaminaTab = Window:CreateTab("Stamina Settings", "arrow-big-right-dash")

local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)

local injectEnabled = true
local disableLoss = false

-- Guardar valores editables
local staminaValues = {
    StaminaLoss = sprintingModule.StaminaLoss,
    StaminaGain = sprintingModule.StaminaGain,
    MinStamina = sprintingModule.MinStamina,
    MaxStamina = sprintingModule.MaxStamina,
    SprintSpeed = sprintingModule.SprintSpeed,
}

---------------------------------------------------------------------
-- FUNCION PRINCIPAL: AHORA SI APLICA TODO
---------------------------------------------------------------------
local function applyStaminaSettings()
    if not injectEnabled then return end

    if not sprintingModule.DefaultsSet then
        sprintingModule.Init()
    end

    -- Aplicar valores del usuario
    sprintingModule.StaminaLoss = staminaValues.StaminaLoss
    sprintingModule.StaminaGain = staminaValues.StaminaGain
    sprintingModule.MinStamina = staminaValues.MinStamina
    sprintingModule.MaxStamina = staminaValues.MaxStamina
    sprintingModule.SprintSpeed = staminaValues.SprintSpeed

    -- Toggle de drenaje
    sprintingModule.StaminaLossDisabled = disableLoss

    -- Notificar cambios
    if sprintingModule.__staminaChangedEvent then
        sprintingModule.__staminaChangedEvent:Fire()
    end
end

---------------------------------------------------------------------
-- INPUTS UI
---------------------------------------------------------------------
local function createInput(label, key)
    StaminaTab:CreateInput({
        Name = label,
        CurrentValue = tostring(staminaValues[key]),
        PlaceholderText = tostring(staminaValues[key]),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            local num = tonumber(text)
            if num then
                staminaValues[key] = num
                applyStaminaSettings()
            end
        end
    })
end

StaminaTab:CreateSection("Survivor stamina settings")

createInput("Stamina Loss", "StaminaLoss")
createInput("Stamina Gain", "StaminaGain")
createInput("Min Stamina", "MinStamina")
createInput("Max Stamina", "MaxStamina")
createInput("Sprint Speed", "SprintSpeed")

StaminaTab:CreateToggle({
    Name = "Disable Stamina Drain",
    CurrentValue = false,
    Flag = "DisableLoss",
    Callback = function(v)
        disableLoss = v
        applyStaminaSettings()
    end
})

---------------------------------------------------------------------
-- AUTO-APLICAR SI RESPAWNEA
---------------------------------------------------------------------

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    applyStaminaSettings()
end)

RunService.RenderStepped:Wait()
applyStaminaSettings()

local Misc = Window:CreateTab("Misc", "plus")

Misc:CreateSection("Pop-ups")

local autoQTE = false

Misc:CreateToggle({
    Name = "Auto Nosf Minigame",
    CurrentValue = false,
    Flag = "AutoQTE",
    Callback = function(v)
        autoQTE = v
    end
})

-- Loop seguro
task.spawn(function()
    while task.wait() do
        if not autoQTE then
            continue
        end

        -- Obtener el botón sin error
        local pg = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
        if not pg then continue end

        local temp = pg:FindFirstChild("TemporaryUI")
        if not temp then continue end

        local qte = temp:FindFirstChild("QTE")
        if not qte then continue end

        local button = qte:FindFirstChild("ActiveButton")
        if not button then continue end

        -- Ejecutar conexiones
        for _, conn in ipairs(getconnections(button.MouseButton1Down)) do
            if conn.Function then
                conn.Function()
            end
        end
    end
end)

Misc:CreateToggle({Name="Anti 1x1x1x1 Popup",CurrentValue=false,Callback=function(v)

    if _G.Anti1x1Loop then task.cancel(_G.Anti1x1Loop); _G.Anti1x1Loop = nil end

    if v then

        _G.Anti1x1Loop = task.spawn(function()

            while task.wait(0.1) do

                local tempUI = LocalPlayer.PlayerGui:FindFirstChild("TemporaryUI")

                if tempUI and tempUI:FindFirstChild("1x1x1x1Popup") then

                    tempUI["1x1x1x1Popup"]:Destroy()

                end

            end

        end)

    end

end})

Misc:CreateSection("Items")

local Workspace = game:GetService("Workspace")

local droppedTools = {}               -- tool names dropped on death
local autoPickupEnabled = false
local hasDropped = false
local currentCharacter

--// Simple alive checker
local function isAlive(char)
	if not char then return false end
	local hum = char:FindFirstChildOfClass("Humanoid")
	return hum and hum.Health > 0
end

--// Drop all tools from backpack + character
local function dropAllTools(char)
	if not char then return end
	table.clear(droppedTools)

	-- Drop all tools from Backpack
	for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
		if tool:IsA("Tool") then
			table.insert(droppedTools, tool.Name)
			tool.Parent = Workspace
		end
	end

	-- Drop all tools from Character
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA("Tool") then
			table.insert(droppedTools, tool.Name)
			tool.Parent = Workspace
		end
	end

	hasDropped = true
end

--// Character Added
LocalPlayer.CharacterAdded:Connect(function(char)
	currentCharacter = char
	hasDropped = false

	char:WaitForChild("Humanoid").Died:Connect(function()
		if autoPickupEnabled then
			dropAllTools(char)
		end
	end)
end)

--// Optimized tool pickup loop
task.spawn(function()
	while task.wait(0.25) do  -- 4× more efficient than running every frame
		if not autoPickupEnabled then continue end
		local char = currentCharacter
		if not isAlive(char) then continue end

		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not humanoid then continue end

		-- Get Map.Ingame reference once
		local map = Workspace:FindFirstChild("Map")
		local ingame = map and map:FindFirstChild("Ingame")

		--// 1. Pick up tools lying in Map.Ingame
		if ingame then
			for _, obj in ipairs(ingame:GetChildren()) do
				if obj:IsA("Tool") then
					humanoid:EquipTool(obj)
				end
			end
		end

		--// 2. Recover tools dropped on death
		for _, toolName in ipairs(droppedTools) do
			local found = Workspace:FindFirstChild(toolName, true)
			if found and found:IsA("Tool") then
				humanoid:EquipTool(found)
			end
		end
	end
end)

--// UI Toggle
Misc:CreateToggle({
	Name = "Auto Pickup Drop Items",
	CurrentValue = false,
	Flag = "AutoPickupTool",
	Callback = function(state)
		autoPickupEnabled = state
	end
})


Misc:CreateSection("Antis")

if not game:IsLoaded() then game.Loaded:Wait() end

getgenv().AntiBanEnabled = false

local function ApplyProtection()
    -- Hook Kick / Ban
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    local old = mt.__namecall
    mt.__namecall = newcclosure(function(self, ...)
        local m = getnamecallmethod()
        if m == "Kick" or m == "kick" or tostring(self):lower():find("ban") then
            return
        end
        return old(self, ...)
    end)
    setreadonly(mt, true)

    -- Hook suspicious remotes
    for _, n in ipairs({"BanRemote", "KickRemote", "LogRemote", "ExploitRemote"}) do
        local r = ReplicatedStorage:FindFirstChild(n, true)
        if r then
            if r:IsA("RemoteEvent") then
                hookfunction(r.FireServer, function() end)
            elseif r:IsA("RemoteFunction") then
                hookfunction(r.InvokeServer, function() end)
            end
        end
    end
end

-- Auto-check cada 5 segundos
task.spawn(function()
    while task.wait() do
        if AntiBanEnabled then
            for _, n in ipairs({"BanRemote", "KickRemote"}) do
                if not ReplicatedStorage:FindFirstChild(n, true) then
                    ApplyProtection()
                end
            end
        end
    end
end)

Misc:CreateButton({
   Name = "Anti Kick (fly and noclip dont really work)",
   Callback = function()
    AntiBanEnabled = true
ApplyProtection()
   end,
})

-- Valores permitidos (NO se tocan)
local Allowed = {
    NosFlying = true,
    NosFlySlow = true,
    NosCataclysm = true,
    VoidRushDash = true,
    SpeedStatus = true,
    HitSpeedBonus = true,
    Guest1337Charge = true,
    BeheadAbility = true,
    ENRAGED = true,
    Sprinting = true,
    Sk8Trick = true,
    ManicFixation = true,
    FixingGenerator = true,
    Sk8 = true
}

local AntiSlowEnabled = false
local AntiSlowConnection = nil

-- Función que forza los speed multipliers
local function AntiSlowLoop()
    local character = LocalPlayer.Character
    if not character then return end

    local speedMultipliers = character:FindFirstChild("SpeedMultipliers")
    if not speedMultipliers then return end

    for _, obj in ipairs(speedMultipliers:GetChildren()) do
        if obj then
            -- Sólo se salvan los permitidos
            if not Allowed[obj.Name] then
                
                obj:Destroy()
            end
        end
    end
end

-- Encender Anti Slow
local function EnableAntiSlow()
    if AntiSlowConnection then AntiSlowConnection:Disconnect() end
    AntiSlowEnabled = true

    AntiSlowConnection = RunService.RenderStepped:Connect(function()
        if AntiSlowEnabled then
            AntiSlowLoop()
        end
    end)
end

-- Apagar Anti Slow
local function DisableAntiSlow()
    AntiSlowEnabled = false
    if AntiSlowConnection then
        AntiSlowConnection:Disconnect()
        AntiSlowConnection = nil
    end
end

-- Reconexión automática al respawn
LocalPlayer.CharacterAdded:Connect(function()
    task.wait()
    if AntiSlowEnabled then
        EnableAntiSlow()
    end
end)

Misc:CreateToggle({
    Name = "Anti Stun",
    CurrentValue = false,
    Callback = function(state)
        if state then
            EnableAntiSlow()
        else
            DisableAntiSlow()
        end
    end
})

Misc:CreateButton({
    Name = "Dusekkar anti-wall break",
    Callback = function()
        local ok, err = pcall(function()
            local util = require(game:GetService("ReplicatedStorage").Modules.Util)

            hookfunction(util.IsOnScreen, function(...)
                -- Solo bloquea la función para evitar detección
                return true
            end)
        end)

        if not ok then
            warn("Anti-wall break error:", err)
        end
    end
})

Misc:CreateSection("Noli")

Misc:CreateSlider({
   Name = "Noli turn speed",
   Range = {0, 10},
   Increment = 0.5,
   CurrentValue = 1,
   Suffix = "Stud (s)",
   Callback = function(val)
        nolimodule.VoidRushTurnSpeed = val
   end,
})

Misc:CreateSection("Sk8 stuff")
Misc:CreateLabel("Sk8 turn speed, trick power, and base speed should be applied before round begins!", 4483362458, Color3.fromRGB(255,100,100), false)

--// Skateboard Anti-Rebound (Cleaned + Editable)

local PlayerName = LocalPlayer.Name

-- Global toggle (used by the hook)
getgenv().BlockSkateRebound = false

-- RemoteEvent reference
local NetworkRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

-- Safety: store original __namecall only once
local originalNamecall
originalNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local args = {...}

    -- Make sure we’re hooking a FireServer call
    if not checkcaller() and getnamecallmethod() == "FireServer" then
        
        if getgenv().BlockSkateRebound then
            local remoteName = tostring(args[1])

            --// 1. Block SkateRebound event
            if remoteName == PlayerName .. "SkateRebound" then
                return nil -- block completely
            end

            --// 2. Handle StopSkate event with collision table
            if remoteName == PlayerName .. "StopSkate" and typeof(args[2]) == "table" then

                for _, value in ipairs(args[2]) do
                    if typeof(value) == "Instance" then
                        
                        -- Replace collision stop with "manual" stop
                        local spoofPacket = {
                            PlayerName .. "StopSkate",
                            { buffer.fromstring("\"Manual\"") }
                        }

                        NetworkRemote:FireServer(unpack(spoofPacket))
                        return nil
                    end
                end
            end
        end
    end

    -- fallback to original
    return originalNamecall(self, ...)
end)


--// UI Toggle
Misc:CreateToggle({
    Name = "Skateboard Ignore Objectables (Anti Rebound)",
    CurrentValue = false,
    Flag = "BlockSkateRebound",
    Callback = function(state)
        getgenv().BlockSkateRebound = state
    end
})

Misc:CreateSlider({
   Name = "Trick Power",
   Range = {0, 1},
   Increment = 0.01,
   CurrentValue = 0.53,
   Callback = function(val)
        sk8module.Sk8TrickJump = val
   end,
})

Misc:CreateSlider({
   Name = "Base Speed",
   Range = {0, 2},
   Increment = 0.01,
   CurrentValue = 1.2,
   Callback = function(val)
        sk8module.Sk8Speed = val
   end,
})

Misc:CreateSlider({
   Name = "Turn Speed",
   Range = {0, 15},
   Increment = 0.5,
   CurrentValue = 2.5,
   Callback = function(val)
        sk8module.Sk8TurnControl = val
   end,
})

local player = Players.LocalPlayer
local Remote = ReplicatedStorage.Modules.Network.RemoteEvent

local interval = 0.5 -- segundos entre cada envío
local running = false

local function Sk8FarmStart()
	running = true
	task.spawn(function()
		while running do
			local args = {
				[1] = player.Name .. "SkateTrick",
				[2] = {}
			}
			Remote:FireServer(unpack(args))
			task.wait(interval)
		end
	end)
end

local function Sk8FarmStop()
	running = false
end

Misc:CreateToggle({
	Name = "Sk8 Farm",
	CurrentValue = false,
	Callback = function(state)
		if state then
			Sk8FarmStart()
		else
			Sk8FarmStop()
		end
	end
})

Misc:CreateSlider({
   Name = "Sk8 farm speed",
   Range = {0, 5},
   Increment = 0.1,
   CurrentValue = 5,
   Suffix = "Sec (s)",
   Callback = function(val)
        interval = val
   end,
})

local player = Players.LocalPlayer
local RemoteEvent = ReplicatedStorage.Modules.Network.RemoteEvent
local UIS = game:GetService("UserInputService")
local device = "Mobile"

local function getBehaviorFolder()
	return ReplicatedStorage:WaitForChild("Assets")
		:WaitForChild("Survivors")
		:WaitForChild("Veeronica")
		:WaitForChild("Behavior")
end

local function getSprintingButton()
	return player.PlayerGui:WaitForChild("MainUI"):WaitForChild("SprintingButton")
end

local behaviorFolder = getBehaviorFolder()

-- Safe connection helper
local function safeConnectPropertyChanged(instance, prop, fn)
	local ok, signal = pcall(function() return instance:GetPropertyChangedSignal(prop) end)
	if ok and signal then
		return signal:Connect(fn)
	end
	return nil
end

-- Manager state
local enabled = false
local activeMonitors = {}
local descendantAddedConn = nil

-- === Internal Functions ===

local function monitorHighlight(h)
	if not h or activeMonitors[h] then return end
	local connections = {}
	local prevState = false

	local function cleanup()
		for _, conn in ipairs(connections) do
			if conn and conn.Connected then conn:Disconnect() end
		end
		activeMonitors[h] = nil
	end

	local function adorneeIsPlayerCharacter(h)
		local adornee = h and h.Adornee
		local char = player.Character
		if not adornee or not char then return false end
		return adornee == char or adornee:IsDescendantOf(char)
	end

	local function onChanged()
		if not enabled then return end
		if not h or not h.Parent then cleanup(); return end

		local currState = adorneeIsPlayerCharacter(h)
		if prevState ~= currState then
			if currState and device == "Mobile" then
				local ok, btn = pcall(getSprintingButton)
				if ok and btn then
					for _, v in pairs(getconnections(btn.MouseButton1Down)) do
						pcall(function() v:Fire() end)
						pcall(function() if v.Function then v:Function() end end)
					end
				end
			end
		end
		prevState = currState
	end

	table.insert(connections, safeConnectPropertyChanged(h, "Adornee", onChanged))
	table.insert(connections, h.AncestryChanged:Connect(function(_, parent)
		if not parent then cleanup() else onChanged() end
	end))
	table.insert(connections, player.CharacterAdded:Connect(onChanged))
	table.insert(connections, player.CharacterRemoving:Connect(onChanged))

	activeMonitors[h] = cleanup
	task.spawn(onChanged)
end

local function startManager()
	if descendantAddedConn then return end
	for _, desc in ipairs(behaviorFolder:GetDescendants()) do
		if desc:IsA("Highlight") then monitorHighlight(desc) end
	end
	descendantAddedConn = behaviorFolder.DescendantAdded:Connect(function(child)
		if child:IsA("Highlight") then monitorHighlight(child) end
	end)
end

local function stopManager()
	if descendantAddedConn and descendantAddedConn.Connected then
		descendantAddedConn:Disconnect()
	end
	descendantAddedConn = nil

	for _, cleanup in pairs(activeMonitors) do
		if type(cleanup) == "function" then pcall(cleanup) end
	end
	activeMonitors = {}
end

local function setEnabled(v)
	if enabled == v then return end
	enabled = v
	if enabled then startManager() else stopManager() end
end

-- === Exposed Function (para toggle externo) ===
getgenv().AutoSprintToggle = setEnabled

Misc:CreateToggle({
    Name = "Sk8 Auto Trick",
    CurrentValue = false,
    Callback = function(state)
        AutoSprintToggle(state)
    end
})

getgenv()._oldFireServer = getgenv()._oldFireServer or nil
getgenv()._VoidRushBypass = getgenv()._VoidRushBypass or false -- toggle СЃРѕСЃС‚РѕСЏРЅРёРµ

-- РҐСѓРє СЃС‚Р°РІРёРј С‚РѕР»СЊРєРѕ РѕРґРёРЅ СЂР°Р·
if not getgenv()._oldFireServer then
    local old
    old = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if self == Remote and method == "FireServer" then
            if args[1] == LocalPlayer.Name .. "VoidRushCollision" then
                if getgenv()._VoidRushBypass then
                    return -- Р±Р»РѕРєРёСЂСѓРµРј С‚РѕР»СЊРєРѕ РµСЃР»Рё toggle РІРєР»СЋС‡С‘РЅ
                end
            end
        end
        return old(self, ...)
    end)

    getgenv()._oldFireServer = old
end

-- Р”РѕР±Р°РІР»СЏРµРј Toggle РІ GUI
Misc:CreateToggle({
    Name = "VoidRush No-Crash",
    CurrentValue = false,
    Callback = function(state)
        getgenv()._VoidRushBypass = state
    end
})

Misc:CreateSection("Other")

Misc:CreateToggle({
    Name = "Enable Chat", 
    CurrentValue = false,
    Callback = function(v)
        game:GetService("TextChatService").ChatWindowConfiguration.Enabled = v
    end
})

Misc:CreateButton({
    Name = "See Hidden Stats",
    Callback = function()
        -- WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
        for _, player in ipairs(Players:GetPlayers()) do
            local privacy = player:FindFirstChild("PlayerData") 
                and player.PlayerData:FindFirstChild("Settings") 
                and player.PlayerData.Settings:FindFirstChild("Privacy")
            
            if privacy then
                local function disableValue(valueName)
                    local val = privacy:FindFirstChild(valueName)
                    if val and val:IsA("BoolValue") then
                        val.Value = false
                    end
                end
                
                disableValue("HideSurvivorWins")
                disableValue("HidePlaytime")
                disableValue("HideKillerWins")
            end
        end

        Players.PlayerAdded:Connect(function(player)
            player.CharacterAdded:Wait()
            task.wait()
            
            local privacy = player:FindFirstChild("PlayerData") 
                and player.PlayerData:FindFirstChild("Settings") 
                and player.PlayerData.Settings:FindFirstChild("Privacy")
            
            if privacy then
                for _, name in ipairs({"HideSurvivorWins", "HidePlaytime", "HideKillerWins"}) do
                    local val = privacy:FindFirstChild(name)
                    if val and val:IsA("BoolValue") then
                        val.Value = false
                    end
                end
            end
        end)
    end
})

Misc:CreateSection("Device Spoof")
local UserInputService = game:GetService("UserInputService")

pcall(function()
    if ReplicatedStorage:FindFirstChild("Modules") and ReplicatedStorage.Modules:FindFirstChild("Network") then
        Network = require(ReplicatedStorage.Modules.Network)
    elseif ReplicatedStorage:FindFirstChild("Network") then
        Network = require(ReplicatedStorage.Network)
    end
end)

-- Detect real device
local function detectOriginalDevice()
    local input = UserInputService:GetLastInputType()
    if input.Name:find("Gamepad") then return "Console" end
    if input.Name:find("Touch") then return "Mobile" end
    return "PC"
end

local spoofEnabled = false
local ForcedDevice = nil
local applyInProgress = false
local appliedDevice = nil
local originalDevice = detectOriginalDevice()
local deviceConn = false -- prevents duplicate event connections

-- DeviceSpoof object
local DeviceSpoof = {}
DeviceSpoof._bind = Instance.new("BindableEvent")
DeviceSpoof.Changed = DeviceSpoof._bind.Event
DeviceSpoof.Value = originalDevice

local function getDeviceLabel()
    local spoofDisplay = appliedDevice or "None"
    return ("Device: %s | Spoofed: %s"):format(originalDevice, spoofDisplay)
end

local statusLabel = Misc:CreateLabel(getDeviceLabel())

-- Apply spoof
local function ApplySpoof()
    if not spoofEnabled then
        --safeNotify({Title="Device Spoofer", Content="Enable spoofing first!", Duration=2})
        return
    end
    if applyInProgress then return end
    applyInProgress = true

    local chosen = ForcedDevice or originalDevice
    if chosen == "Disable" then chosen = originalDevice end

    DeviceSpoof.Value = chosen
    appliedDevice = chosen

    pcall(function()
        DeviceSpoof._bind:Fire(chosen)
    end)

    task.spawn(function()
        pcall(function()
            if Network then
                Network:FireServerConnection("SetDevice", "REMOTE_EVENT", chosen)
            end
        end)
        applyInProgress = false
    end)

    statusLabel:Set(getDeviceLabel())
   -- safeNotify({Title="Device Spoofer", Content="Device set to " .. chosen, Duration=2})
end

-- Dropdown
local dropdownOptions = {"Disable", "Console", "Mobile", "PC", "Unknown"}

Misc:CreateDropdown({
    Name = "Select Device",
    Options = dropdownOptions,
    CurrentOption = {"Disable"},
    MultipleOptions = false,
    Callback = function(opts)
        local selected = opts[1]

        if selected == "Disable" then
            spoofEnabled = false
            ForcedDevice = nil
            appliedDevice = nil
            DeviceSpoof.Value = originalDevice

            pcall(function()
                DeviceSpoof._bind:Fire(originalDevice)
            end)

            statusLabel:Set(getDeviceLabel())
            return
        end

        -- Set to actual forced value
        ForcedDevice = (selected == "Unknown") and "Idk" or selected
    end
})

-- Apply Button
Misc:CreateButton({
    Name = "Apply Device Spoof",
    Callback = function()
        spoofEnabled = true
        ApplySpoof()

        -- Prevent connecting multiple times
        if not deviceConn then
            deviceConn = true

            UserInputService.LastInputTypeChanged:Connect(function()
                if spoofEnabled then
                    ApplySpoof()
                end
            end)
        end
    end
})


local Combat = Window:CreateTab("Combat", "swords")
Combat:CreateSection("Sk8 Bumper")
--Combat:CreateLabel("Sk8 turn speed, trick power, and Sk8 base speed should be applied before round begins!", 4483362458, Color3.fromRGB(255,100,100), false)

_G.TiltEnabled = _G.TiltEnabled or false
_G.TiltPitch = _G.TiltPitch or 40
_G.TiltForward = _G.TiltForward or 0.06
_G.TiltUp = _G.TiltUp or 0.08

local player = Players.LocalPlayer

local ANIM_ID = "117058860640843" -- anim a detectar

---------------------------------------------------------------------
-- Detectar animación
---------------------------------------------------------------------
local function isMatchAnimation(anim)
    if not anim or not anim.AnimationId then return false end
    return tostring(anim.AnimationId):find(ANIM_ID, 1, true) ~= nil
end

---------------------------------------------------------------------
-- Core del tilt / pitch dinámico
---------------------------------------------------------------------
local function attachTiltToCharacter(character)
    if not character then return end

    local humanoid = character:WaitForChild("Humanoid", 5)
    if not humanoid then return end

    local animator = humanoid:WaitForChild("Animator", 5)
    if not animator then return end

    local active = {}

    animator.AnimationPlayed:Connect(function(track)
        if not isMatchAnimation(track.Animation) then return end
        if active[track] then return end
        active[track] = true

        local hrp = character:WaitForChild("HumanoidRootPart", 3)
        if not hrp then
            active[track] = nil
            return
        end

        local conn
        conn = RunService.RenderStepped:Connect(function()
            if not _G.TiltEnabled then
                if conn then conn:Disconnect() end
                active[track] = nil
                return
            end

            if not hrp or not hrp.Parent then
                if conn then conn:Disconnect() end
                active[track] = nil
                return
            end

            -------------------------------------------------
            -- Leer sliders
            -------------------------------------------------
            local pitch = math.rad(_G.TiltPitch)
            local forward = _G.TiltForward
            local up = _G.TiltUp

            -------------------------------------------------
            -- Dirección horizontal sin cambiar yaw
            -------------------------------------------------
            local lv = hrp.CFrame.LookVector
            local flat = Vector3.new(lv.X, 0, lv.Z)
            if flat.Magnitude == 0 then
                flat = Vector3.new(0, 0, -1)
            else
                flat = flat.Unit
            end

            -------------------------------------------------
            -- Crear CFrame suave
            -------------------------------------------------
            local pos = hrp.Position + flat * forward + Vector3.new(0, up, 0)
            local base = CFrame.new(pos, pos + flat)
            local final = base * CFrame.Angles(pitch, 0, 0)

            -------------------------------------------------
            -- Aplicar
            -------------------------------------------------
            hrp.CFrame = final
        end)

        -- Cuando la animación termina, dejar de forzar el tilt
        track.Stopped:Connect(function()
            if conn then conn:Disconnect() end
            active[track] = nil
        end)
    end)
end

---------------------------------------------------------------------
-- Detectar respawn y reiniciar sistema
---------------------------------------------------------------------
local function setupCharacter(char)
    task.wait(0.2)
    attachTiltToCharacter(char)
end

if player.Character then
    setupCharacter(player.Character)
end

player.CharacterAdded:Connect(setupCharacter)

Combat:CreateToggle({
    Name = "Veeronica Better Bumper",
    CurrentValue = false,
    Callback = function(state)
        _G.TiltEnabled = state
    end
})

Combat:CreateSlider({
   Name = "Pitch",
   Range = {-45, 40},
   Increment = 1,
   CurrentValue = 40,
   Callback = function(val)
        _G.TiltPitch = val
   end,
})

Combat:CreateSlider({
   Name = "Forward Offset",
   Range = {0, 0.1},
   Increment = 0.01,
   CurrentValue = 0.06,
   Callback = function(val)
        _G.TiltForward = val
   end,
})

Combat:CreateSlider({
   Name = "Up Offset",
   Range = {0, 2},
   Increment = 0.01,
   CurrentValue = 0.08,
   Callback = function(val)
        _G.TiltUp = val
   end,
})

Combat:CreateSection("Chance")

local autoAimEnabled = false
local manualPrediction = 4
local friendlyFire = false

Combat:CreateToggle({
    Name = "Auto Aim",
    CurrentValue = false,
    Flag = "AutoAim",
    Callback = function(v)
        autoAimEnabled = v
        if not v then
            -- Reset aiming state when disabled
            aiming = false
            if autoRotateLocked and Humanoid then
                autoRotateLocked = false
                Humanoid.AutoRotate = originalAutoRotate == nil or originalAutoRotate
            end
        end
    end
})

Combat:CreateSlider({
    Name = "Prediction",
    Range = {0, 20},
    Increment = 1,
    Suffix = " studs",
    CurrentValue = 4,
    Flag = "AimPrediction",
    Callback = function(val)
        manualPrediction = val
    end
})

Combat:CreateToggle({
    Name = "Friendly Fire Mode",
    CurrentValue = false,
    Flag = "FriendlyFire",
    Callback = function(v)
        friendlyFire = v
    end
})

--// State
local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aimDuration = 1.7
local aiming = false
local autoRotateLocked = false

local originalWS, originalJP, originalAutoRotate = nil, nil, nil

--// Tracked animations
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true
}

--// Smoothing variables
local lastRotationTime = tick()
local targetYaw = 0
local currentYaw = 0
local rotationLerpSpeed = 0.15 -- Adjust for smoother/faster rotation
local lastValidTarget = nil
local velocityHistory = {}
local lastFramePositions = {}
local smoothPrediction = true

--// Character setup
local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
    currentYaw = HRP.Rotation.Y
    targetYaw = HRP.Rotation.Y
    
    -- Reset tracking
    velocityHistory = {}
    lastFramePositions = {}
    lastValidTarget = nil
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

--// Get animation IDs currently playing
local function getPlayingAnimationIds()
    local ids = {}
    if Humanoid then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            if track.Animation and track.Animation.AnimationId then
                local id = track.Animation.AnimationId:match("%d+")
                if id then ids[id] = true end
            end
        end
    end
    return ids
end

--// Smoothed velocity prediction
local function getSmoothedVelocity(targetHRP)
    local currentTime = tick()
    local velocity = targetHRP.Velocity
    
    -- Store recent velocities for smoothing
    table.insert(velocityHistory, 1, {
        velocity = velocity,
        time = currentTime,
        position = targetHRP.Position
    })
    
    -- Clean old entries (keep last 0.3 seconds)
    local maxAge = 0.3
    while #velocityHistory > 0 and (currentTime - velocityHistory[#velocityHistory].time) > maxAge do
        velocityHistory[#velocityHistory] = nil
    end
    
    -- If we have enough history, use weighted average
    if #velocityHistory > 1 then
        local totalWeight = 0
        local weightedVel = Vector3.zero
        
        for i, entry in ipairs(velocityHistory) do
            -- Recent entries get more weight
            local age = currentTime - entry.time
            local weight = 1 - (age / maxAge)
            weight = math.max(weight, 0.1) -- Minimum weight
            
            weightedVel = weightedVel + (entry.velocity * weight)
            totalWeight = totalWeight + weight
        end
        
        if totalWeight > 0.01 then
            velocity = weightedVel / totalWeight
        end
    end
    
    -- Also use position-based velocity for more accuracy
    if lastFramePositions[targetHRP] then
        local lastPos = lastFramePositions[targetHRP]
        local frameTime = currentTime - (lastFramePositions[targetHRP].time or currentTime)
        if frameTime > 0 then
            local posVelocity = (targetHRP.Position - lastPos.pos) / frameTime
            -- Blend position-based velocity with physics velocity
            velocity = velocity:Lerp(posVelocity, 0.3)
        end
    end
    
    lastFramePositions[targetHRP] = {
        pos = targetHRP.Position,
        time = currentTime
    }
    
    return velocity
end

--// Adjust prediction based on distance
local function getDistanceBasedPrediction(targetPos, targetVelocity, ourPos)
    local distance = (targetPos - ourPos).Magnitude
    
    -- Dynamic prediction: less prediction at close range, more at distance
    local basePrediction = manualPrediction
    local predictionFactor = 0
    
    if distance < 10 then
        -- Very close: minimal prediction
        predictionFactor = 0.1
    elseif distance < 30 then
        -- Close-mid range: moderate prediction
        predictionFactor = 0.3
    elseif distance < 60 then
        -- Mid range: normal prediction
        predictionFactor = 0.7
    else
        -- Long range: full prediction
        predictionFactor = 1.0
    end
    
    -- Adjust based on target's speed
    local speed = targetVelocity.Magnitude
    if speed > 50 then
        predictionFactor = math.min(predictionFactor * 1.5, 1.0)
    end
    
    return targetVelocity * (basePrediction * predictionFactor)
end

--// Get nearest target from correct folder
local function getValidTarget()
    if not HRP then return nil end

    local base = workspace:FindFirstChild("Players")
    if not base then return nil end

    local folder = friendlyFire and "Survivors" or "Killers"
    local targetFolder = base:FindFirstChild(folder)
    if not targetFolder then return nil end

    local closest, closestDist = nil, math.huge
    local ourPos = HRP.Position

    for _, model in ipairs(targetFolder:GetChildren()) do
        if model ~= LocalPlayer.Character and model:FindFirstChild("HumanoidRootPart") then
            local root = model.HumanoidRootPart
            
            -- Check line of sight (optional but recommended)
            local direction = (root.Position - ourPos).Unit
            local ray = Ray.new(ourPos + Vector3.new(0, 2, 0), direction * 500)
            local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
            
            if hit and hit:IsDescendantOf(model) then
                local dist = (root.Position - ourPos).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closest = root
                end
            elseif not hit then
                -- Fallback if ray misses
                local dist = (root.Position - ourPos).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closest = root
                end
            end
        end
    end

    return closest, closestDist
end

-- Solo la parte de rotación suave del aimbot
RunService.RenderStepped:Connect(function(dt)
    if not active or not Humanoid or not HRP then return end

    local playing = getPlayingAnimationIds()
    local triggered = false
    for id in pairs(trackedAnimations) do
        if playing[id] then
            triggered = true
            break
        end
    end

    if triggered then
        lastTriggerTime = tick()
        aiming = true
    end

    if aiming and tick() - lastTriggerTime <= aimDuration then
        -- Freeze pero mantenerse derecho
        Humanoid.AutoRotate = false
        HRP.AssemblyAngularVelocity = Vector3.zero

        local targetHRP = getValidTarget()
        if targetHRP then
            -- Posición predicha
            local predictedPos = targetHRP.Position + (targetHRP.Velocity * prediction)
            
            -- Calcular dirección
            local direction = (predictedPos - HRP.Position)
            if direction.Magnitude < 0.01 then return end
            direction = direction.Unit
            
            -- Rotación suave usando Lerp
            local targetCFrame = CFrame.new(HRP.Position, HRP.Position + Vector3.new(direction.X, 0, direction.Z))
            HRP.CFrame = HRP.CFrame:Lerp(targetCFrame, 0.3) -- Ajusta este número para más suavidad
        end
    elseif aiming then
        aiming = false
        Humanoid.AutoRotate = true
    end
end)

local player = Players.LocalPlayer
local remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

if remote and remote.ClassName == "RemoteEvent" then
    local blockEnabled = true
    local blockedName = player.Name .. "ChanceFireShot"
    local delayDuration = 3
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    
    setreadonly(mt, false)
    mt.__namecall = function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if blockEnabled and method == "FireServer" then
            local firstArg = args[1]
            if type(firstArg) == "string" and firstArg == blockedName then
                task.delay(delayDuration, function()
                    blockEnabled = false
                    local character = player.Character
                    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if rootPart then
                        local lookVector = rootPart.CFrame.LookVector
                        local data = {Vector3.new(lookVector.X, lookVector.Y, lookVector.Z)}
                        remote:FireServer(firstArg, data)
                        blockEnabled = true
                    else
                        blockEnabled = true
                    end
                end)
                return
            end
        end
        
        return oldNamecall(self, ...)
    end
    setreadonly(mt, true)

    Combat:CreateToggle({
        Name = "Flintlock Hitbox delay",
        Flag = "StoringHitboxGun",
        CurrentValue = fallse,
        Callback = function(value)
            blockEnabled = value
        end
    })

    Combat:CreateInput({
        Name = "Delay (recommended under 10)",
        Flag = "DelayDurationseconds",
        PlaceholderText = "2",
        RemoveTextAfterFocusLost = false,
        Callback = function(input)
            local num = tonumber(input)
            if num and num > 0 then
                delayDuration = num
            end
        end
    })
end

Combat:CreateSection("John doe")

local lp = Players.LocalPlayer
repeat task.wait() until lp.Character

--======== ESTADO ========
local enabled = false
local RANGE = 14

local SPAM_DURATION = 1.2
local SPAM_DELAY = 0.08
local COOLDOWN_TIME = 2

local activeCooldowns = {}

--======== HABILIDAD ACTUAL ========
local currentAbility = "404Error" -- default

--======== REMOTE (FORMATO CORRECTO) ========
local remoteEvent = ReplicatedStorage
	:WaitForChild("Modules")
	:WaitForChild("Network")
	:WaitForChild("RemoteEvent")

local fireArgs = {
	[1] = "UseActorAbility",
	[2] = {
		[1] = currentAbility
	}
}

--======== SOUNDS A DETECTAR ========
local TRIGGER_SOUNDS = {
	["86710781315432"] = true,
    ["121717335514560"] = true,
    ["109931874166612"] = true,
    ["100918679787313"] = true,
    ["609342351"] = true,
    ["86710781315432"] = true,
    ["99820161736138"] = true,
    ["83851356262523"] = true,
    ["132596270805754"] = true,
    ["74027282199279"] = true,
	["99820161736138"] = true,
	["609342351"] = true,
	["81976396729343"] = true,
	["12222225"] = true,
	["80521472651047"] = true,
	["139012439429121"] = true,
	["91194698358028"] = true,
	["111910850942168"] = true,
	["83851356262523"] = true,
}

--======== UTILIDADES ========
local function getSoundId(sound)
	return tostring(sound.SoundId):match("%d+")
end

local function enemyPlayingTriggerSound(player)
	local char = player.Character
	if not char then return false end

	for _, obj in ipairs(char:GetDescendants()) do
		if obj:IsA("Sound") and obj.IsPlaying then
			local id = getSoundId(obj)
			if id and TRIGGER_SOUNDS[id] then
				return true
			end
		end
	end
	return false
end
local lastCheck = 0
local CHECK_INTERVAL = 0.15

RunService.Heartbeat:Connect(function()
    if tick() - lastCheck < CHECK_INTERVAL then return end
    lastCheck = tick()
	if not enabled then return end

	local myChar = lp.Character
	local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
	if not myHRP then return end

	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= lp and player.Character then
			local targetHRP = player.Character:FindFirstChild("HumanoidRootPart")
			if not targetHRP then continue end

			local dist = (targetHRP.Position - myHRP.Position).Magnitude
			if dist > RANGE then continue end

			if activeCooldowns[player] and tick() - activeCooldowns[player] < COOLDOWN_TIME then
				continue
			end

			if enemyPlayingTriggerSound(player) then
				activeCooldowns[player] = tick()

				task.spawn(function()
					local start = tick()
					local MAX_FIRES = 10
local fires = 0

while tick() - start < SPAM_DURATION and fires < MAX_FIRES and enabled do
    remoteEvent:FireServer(unpack(fireArgs))
    fires += 1
    task.wait(SPAM_DELAY)
end

				end)
			end
		end
	end
end)

--=====================
-- UI EXTERNA (COMBAT)
--=====================

Combat:CreateToggle({
	Name = "Auto Ability",
	CurrentValue = false,
	Flag = "AutoAbilityToggle",
	Callback = function(Value)
		enabled = Value
	end,
})

Combat:CreateSlider({
	Name = "Detection Range",
	Range = {0, 100},
	Increment = 1,
	Suffix = "Studs",
	CurrentValue = RANGE,
	Flag = "AutoAbilityRange",
	Callback = function(Value)
		RANGE = Value
	end,
})

Combat:CreateDropdown({
	Name = "Ability Mode",
	Options = {
		"404Error",
		"DigitalFootprint",
		"CorruptEnergy"
	},
	CurrentOption = {"404Error"},
	MultipleOptions = false,
	Flag = "AutoAbilityDropdown",
	Callback = function(Options)
		local selected = Options[1]
		if selected then
			currentAbility = selected
			fireArgs[2][1] = selected -- 🔥 CAMBIO CLAVE 🔥
		end
	end,
})
    
Combat:CreateSection("Reach")

                              
_G.JasonHitbox = _G.JasonHitbox or false
_G.hitboxnearestdist = _G.hitboxnearestdist or 10

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local AttackAnimations = loadstring(game:HttpGet("https://raw.githubusercontent.com/sigmaone-bot/Bullshit/refs/heads/main/AttackAnims"))()

local hitboxConnection -- conexión principal (única)

---------------------------------------------------------
-- INICIAR EL SISTEMA DE HITBOX
---------------------------------------------------------
local function startHitbox()
    -- Si ya existe una conexión, desconectarla para reemplazarla
    if hitboxConnection then
        hitboxConnection:Disconnect()
        hitboxConnection = nil
    end

    hitboxConnection = RunService.Heartbeat:Connect(function()
        if not _G.JasonHitbox then return end

        -- seguridad máxima
        local reach = tonumber(_G.hitboxnearestdist) or 10
        if reach <= 0 then reach = 10 end

        local char = LocalPlayer.Character
        if not char then return end

        local humanoid = char:FindFirstChild("Humanoid")
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not humanoid or not hrp then return end

        ---------------------------------------------------------
        -- DETECTAR SI ESTÁ ATACANDO
        ---------------------------------------------------------
        local isAttacking = false

        for _, track in humanoid:GetPlayingAnimationTracks() do
            local id = track.Animation.AnimationId
            if AttackAnimations[id] and (track.TimePosition / track.Length < 0.75) then
                isAttacking = true
                break
            end
        end

        if not isAttacking then return end

        ---------------------------------------------------------
        -- BUSCAR AL TARGET MÁS CERCANO
        ---------------------------------------------------------
        local nearestTarget = nil
        local nearestDistance = math.huge

        local function findNearest(folder)
            if not folder then return end
            for _, model in pairs(folder:GetChildren()) do
                local hrp2 = model:FindFirstChild("HumanoidRootPart")
                if hrp2 then
                    local dist = (hrp2.Position - hrp.Position).Magnitude
                    if dist < nearestDistance then
                        nearestDistance = dist
                        nearestTarget = model
                    end
                end
            end
        end

        local parentName = char.Parent and char.Parent.Name

        if parentName == "Killers" then
            findNearest(workspace.Players:FindFirstChild("Survivors"))
            findNearest(workspace.Map:FindFirstChild("NPCs", true))
        else
            findNearest(workspace.Players:FindFirstChild("Killers"))
            findNearest(workspace.Map:FindFirstChild("NPCs", true))
        end

        if not nearestTarget then return end

        ---------------------------------------------------------
        -- COMPARACIÓN SEGURA (NUNCA CRASHEA)
        ---------------------------------------------------------
        local distNum = tonumber(nearestDistance) or math.huge
        if distNum > reach then return end

        ---------------------------------------------------------
        -- MOVERSE HACIA EL TARGET
        ---------------------------------------------------------
        local targetPos = nearestTarget.HumanoidRootPart.Position
        local oldVel = hrp.Velocity

        local neededVel = (targetPos - hrp.Position) * 12

        hrp.Velocity = neededVel
        RunService.RenderStepped:Wait()
        hrp.Velocity = oldVel
    end)
end

---------------------------------------------------------
-- REINICIAR AL RESPAWN
---------------------------------------------------------
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    startHitbox()
end)

-- inicio inicial
startHitbox()

---------------------------------------------------------
-- UI
---------------------------------------------------------

Combat:CreateToggle({
    Name = "Reach",
    CurrentValue = false,
    Callback = function(state)
        _G.JasonHitbox = state
    end
})

Combat:CreateSlider({
    Name = "Reach Distance",
    Increment = 0.5,
    CurrentValue = 7,
    Range = {1, 10},
    Suffix = " studs",
    Callback = function(val)
        _G.hitboxnearestdist = val
    end
})

local Gens = Window:CreateTab("Generators", "swords")

Gens:CreateButton({
    Name = "Fix generator manual",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/tPWnvGj6"))()
        --WindUI:Notify({ Title = "Fix generator manual", Content = "hi from bublik6241", Duration = 2 })
    end
})

local Anims = Window:CreateTab("Animations", "swords")

local player = Players.LocalPlayer

-- IDs de animaciones
local triggerAnimId = "rbxassetid://83685305553364"
local replaceAnimId = "rbxassetid://70447634862911"

local animationToggleEnabled = false
local currentCharacter = nil
local currentReplacementTrack = nil
local connection = nil

local function setupAnimationReplacement(char)
    if not char then return end
    
    local humanoid = char:WaitForChild("Humanoid")
    
    local replacementAnim = Instance.new("Animation")
    replacementAnim.AnimationId = replaceAnimId
    currentReplacementTrack = humanoid:LoadAnimation(replacementAnim)
    
    connection = humanoid.AnimationPlayed:Connect(function(track)
        if not animationToggleEnabled then return end
        
        if track.Animation and track.Animation.AnimationId == triggerAnimId then
            track:Stop()
            currentReplacementTrack:Play()
        end
    end)
end

local function cleanup()
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    if currentReplacementTrack then
        currentReplacementTrack:Stop()
        currentReplacementTrack = nil
    end
    
    currentCharacter = nil
end

local function onCharacterAdded(char)
    cleanup()
    currentCharacter = char
    setupAnimationReplacement(char)
end

-- Toggle system
Anims:CreateToggle({
    Name = "Old Hacklord mass infection",
    Flag = "AnimationReplacer",
    CurrentValue = animationToggleEnabled,
    Callback = function(value)
        animationToggleEnabled = value
        
        if value then
            -- Enable the system
            if not currentCharacter and player.Character then
                onCharacterAdded(player.Character)
            end
        else
            -- Disable the system
            if currentReplacementTrack then
                currentReplacementTrack:Stop()
            end
        end
    end
})

-- Character handling
player.CharacterAdded:Connect(function(char)
    if animationToggleEnabled then
        onCharacterAdded(char)
    end
end)

if player.Character and animationToggleEnabled then
    onCharacterAdded(player.Character)
end

local animToStopId = "rbxassetid://91758760621955"

local stopAnimToggleEnabled = false
local currentCharacter = nil
local connection = nil

local function setupAnimationStopper(char)
    if not char then return end
    
    local humanoid = char:WaitForChild("Humanoid")
    
    connection = humanoid.AnimationPlayed:Connect(function(track)
        if not stopAnimToggleEnabled then return end
        
        if track.Animation and track.Animation.AnimationId == animToStopId then
            track:Stop()
        end
    end)
end

local function cleanup()
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    currentCharacter = nil
end

local function onCharacterAdded(char)
    cleanup()
    currentCharacter = char
    if stopAnimToggleEnabled then
        setupAnimationStopper(char)
    end
end

-- Toggle system
Anims:CreateToggle({
    Name = "Remove Void Rush Charge up",
    Flag = "StopSpecificAnimation",
    CurrentValue = stopAnimToggleEnabled,
    Callback = function(value)
        stopAnimToggleEnabled = value
        
        if value then
            -- Enable the system
            if not currentCharacter and player.Character then
                onCharacterAdded(player.Character)
            end
        else
            -- Disable the system
            cleanup()
        end
    end
})

-- Character handling
player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
    onCharacterAdded(player.Character)
end
